<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="LRUWe will used the doubly-linked list to build the LRU Dlink will have the prev pointer and the next pointer the key :when we put new element into LRU we need to check whether we should remove the le">
<meta property="og:type" content="article">
<meta property="og:title" content="Discussion of Leecode question">
<meta property="og:url" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/index.html">
<meta property="og:site_name" content="StigWang&#39;s code recording">
<meta property="og:description" content="LRUWe will used the doubly-linked list to build the LRU Dlink will have the prev pointer and the next pointer the key :when we put new element into LRU we need to check whether we should remove the le">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdn.net/20180605194356213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://img-blog.csdn.net/20180605194408675?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240428164330973.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/300.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/1671.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240522030445984.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240522043611599.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240526000548963.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240526013617304.png">
<meta property="og:image" content="https://pic.leetcode.cn/1680534488-qZHfMY-1000-3d-cut.png">
<meta property="og:image" content="https://pic.leetcode.cn/1680534839-WSibYe-1000-2d.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240530064021805.png">
<meta property="og:image" content="https://pic.leetcode.cn/1689398667-omjvbD-lc834.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/9dc2e1487aa9aba63f1a44319471e683.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/c57f31f17f706c9bf90cfca384e8437d.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/58262059065813797b91b846a21857b9.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/67314638d022f057e46a0a5331d98bf6.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/1f065ca28d2c1ac76f8efac1f61be0a8.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/1747b4d7cada1a435b8fd711333d1b82.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/413f5fba355d25e2f47f381d271b01cf.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/ad272c2be376af3e97c3b3829ea65bd0.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/4f126a11e34344a58d0c7c2bbef095e5.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/c2ae47c1e48d3f511a022cba2b20205c.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/4fb54a64519b69eafd6a16557401c47b.png">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2934367/6a91acbb17d5f6a0033c92c07e301fc5.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1655808248-EfPSRV-1.svg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1655808231-VTJvAM-2.svg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1655808224-kMYiyq-3.svg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1654588378-Bhkpkc-3.svg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1649014227-ofNuJc-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1649015091-pyEACj-image.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240618001223909.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/2386.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240710104545701.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1604155779-zGMFLS-image.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/set.png">
<meta property="og:image" content="http://example.com/2023/10/23/Discussion-of-Leecode-question/set2.png">
<meta property="article:published_time" content="2023-10-23T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-17T10:27:05.131Z">
<meta property="article:author" content="stigwang">
<meta property="article:tag" content="-leecode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/20180605194356213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">

<link rel="canonical" href="http://example.com/2023/10/23/Discussion-of-Leecode-question/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Discussion of Leecode question | StigWang's code recording</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StigWang's code recording</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/Discussion-of-Leecode-question/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stigwang">
      <meta itemprop="description" content="show me the code！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StigWang's code recording">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Discussion of Leecode question
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-24 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-24T00:00:00+08:00">2023-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-17 18:27:05" itemprop="dateModified" datetime="2024-07-17T18:27:05+08:00">2024-07-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>We will used the doubly-linked list to build the LRU Dlink will have the prev pointer and the next pointer</p>
<p>the key :when we put new element into LRU we need to check whether we should remove the less used element, the key is used to use the method map.remove(redn.key) and update the hashmap</p>
<p>the value: use it to store the value;  </p>
<p>the map : used to find the Dlinknode to choose update or delete the Dlinknode;</p>
<p>important method: addtohead removenode </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,DLinkedNode&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line">        <span class="keyword">public</span>  <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.capacity=capacity;</span><br><span class="line">            <span class="built_in">this</span>.size=<span class="number">0</span>;   </span><br><span class="line">            head=<span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">            tail=<span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">            head.next=tail;</span><br><span class="line">            tail.prev=head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">dn</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (dn == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            moveToHead(dn);</span><br><span class="line">            <span class="keyword">return</span> dn.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            DLinkedNode dn=map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(dn==<span class="literal">null</span>)&#123;</span><br><span class="line">                DLinkedNode node=<span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key,value);</span><br><span class="line">                addToHead(node);</span><br><span class="line">                map.put(key, node);</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">if</span>(size&gt;capacity) &#123;</span><br><span class="line">                    <span class="type">DLinkedNode</span> <span class="variable">redn</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                    map.remove(redn.key);</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                dn.value=value;</span><br><span class="line">                moveToHead(dn);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>With the time expiring requirement</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双向链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="type">long</span> expireTime;</span><br><span class="line">    Node&lt;K, V&gt; prev;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = expireTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现带过期时间的LRU缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCacheWithExpiration</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, Node&lt;K, V&gt;&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt; head; <span class="comment">// 最近访问的节点（头部）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt; tail; <span class="comment">// 最久未访问的节点（尾部）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCacheWithExpiration</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">this</span>.head.next = <span class="built_in">this</span>.tail;</span><br><span class="line">        <span class="built_in">this</span>.tail.prev = <span class="built_in">this</span>.head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查是否过期</span></span><br><span class="line">            <span class="keyword">if</span> (node.expireTime &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                removeNode(node);</span><br><span class="line">                cache.remove(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动节点到头部（表示最近使用）</span></span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">long</span> expireTimeMillis)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 key 已存在，则更新 value 和过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = cache.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.expireTime = System.currentTimeMillis() + expireTimeMillis;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新节点插入到头部</span></span><br><span class="line">            Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, System.currentTimeMillis() + expireTimeMillis);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果超过容量，删除尾部节点</span></span><br><span class="line">            <span class="keyword">if</span> (cache.size() &gt; capacity) &#123;</span><br><span class="line">                Node&lt;K, V&gt; tailNode = removeTail();</span><br><span class="line">                cache.remove(tailNode.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; tailNode = tail.prev;</span><br><span class="line">        removeNode(tailNode);</span><br><span class="line">        <span class="keyword">return</span> tailNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node&lt;K, V&gt; node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">long</span> expireTimeMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 key 已存在，则更新 value 和过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">        Node&lt;K, V&gt; node = cache.get(key);</span><br><span class="line">        node.value = value;</span><br><span class="line">        node.expireTime = System.currentTimeMillis() + expireTimeMillis;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新节点插入到头部</span></span><br><span class="line">        Node&lt;K, V&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value, System.currentTimeMillis() + expireTimeMillis);</span><br><span class="line">        cache.put(key, newNode);</span><br><span class="line">        addToHead(newNode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果超过容量，删除尾部节点</span></span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt; capacity) &#123;</span><br><span class="line">            removeExpiredNodes();</span><br><span class="line">            <span class="keyword">if</span> (cache.size() &gt; capacity) &#123;</span><br><span class="line">                Node&lt;K, V&gt; tailNode = removeTail();</span><br><span class="line">                cache.remove(tailNode.key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeExpiredNodes</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; node = tail.prev;</span><br><span class="line">    <span class="keyword">while</span> (node != head &amp;&amp; node.expireTime &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        cache.remove(node.key);</span><br><span class="line">        node = tail.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1584. Min Cost to Connect All Points  https://leetcode.com/problems/min-cost-to-connect-all-points/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="type">DisjointSetUnion</span> <span class="variable">dsu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisjointSetUnion</span>(n);</span><br><span class="line">        List&lt;Edge&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Edge&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                edges.add(<span class="keyword">new</span> <span class="title class_">Edge</span>(dist(points, i, j), i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(edges, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Edge&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge edge1, Edge edge2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge1.len - edge2.len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> edge.len, x = edge.x, y = edge.y;</span><br><span class="line">            <span class="keyword">if</span> (dsu.unionSet(x, y)) &#123;</span><br><span class="line">                ret += len;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dist</span><span class="params">(<span class="type">int</span>[][] points, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + Math.abs(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DisjointSetUnion</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] f;</span><br><span class="line">        <span class="type">int</span>[] rank;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DisjointSetUnion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.n = n;</span><br><span class="line">            <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            Arrays.fill(<span class="built_in">this</span>.rank, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.f = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.f[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f[x] == x ? x : (f[x] = find(f[x]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x), fy = find(y);</span><br><span class="line">            <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rank[fx] &lt; rank[fy]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> fx;</span><br><span class="line">                fx = fy;</span><br><span class="line">                fy = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            rank[fx] += rank[fy];</span><br><span class="line">            f[fy] = fx;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> len, x, y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.len = len;</span><br><span class="line">            <span class="built_in">this</span>.x = x;</span><br><span class="line">            <span class="built_in">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p><img src="https://img-blog.csdn.net/20180605194356213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180605194408675?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//743. Network Delay Time  https://leetcode.com/problems/network-delay-time/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Arrays.fill(g[i], INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : times) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>] - <span class="number">1</span>, y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            g[x][y] = t[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x=-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!used[y]&amp;&amp;(x==-<span class="number">1</span>||dist[y]&lt;dist[x]))&#123;</span><br><span class="line">                    x=y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            used[x]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">                 dist[y]=Math.min(dist[y],dist[x]+g[x][y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Arrays.stream(dist).max().getAsInt();</span><br><span class="line">        <span class="keyword">return</span> ans == INF ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1976-到达目的地的方案数"><a href="#1976-到达目的地的方案数" class="headerlink" title="1976. 到达目的地的方案数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/">1976. 到达目的地的方案数</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPaths</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] e = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        e[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] road : roads) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> road[<span class="number">0</span>], y = road[<span class="number">1</span>], t = road[<span class="number">2</span>];</span><br><span class="line">        e[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, t&#125;);</span><br><span class="line">        e[y].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, t&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span>[] dis = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    Arrays.fill(dis, Long.MAX_VALUE);</span><br><span class="line">    <span class="type">int</span>[] ways = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;<span class="type">long</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">long</span>[]&gt;((a, b) -&gt; Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">long</span>[] arr = pq.poll();</span><br><span class="line">        <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> (<span class="type">int</span>) arr[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; dis[u]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] next : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> next[<span class="number">0</span>], w = next[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (t + w &lt; dis[v]) &#123;</span><br><span class="line">                dis[v] = t + w;</span><br><span class="line">                ways[v] = ways[u];</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;t + w, v&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t + w == dis[v]) &#123;</span><br><span class="line">                ways[v] = (ways[u] + ways[v]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>画每个节点的距离表格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">110</span>, M = <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span></span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] ts, <span class="type">int</span> _n, <span class="type">int</span> _k)</span> &#123;</span><br><span class="line">        n = _n; k = _k;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                w[i][j] = w[j][i] = i == j ? <span class="number">0</span> : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : ts) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> t[<span class="number">0</span>], v = t[<span class="number">1</span>], c = t[<span class="number">2</span>];</span><br><span class="line">            w[u][v] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        floyd();</span><br><span class="line">        <span class="comment">// 遍历答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, w[k][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt;= INF / <span class="number">2</span> ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// floyd 基本流程为三层循环：</span></span><br><span class="line">        <span class="comment">// 枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作        </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    w[i][j] = Math.min(w[i][j], w[i][p] + w[p][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="BellmanFord"><a href="#BellmanFord" class="headerlink" title="BellmanFord"></a>BellmanFord</h2><p><strong>Dijstra不能运用在含负权边的图</strong></p>
<p>利用Dijstra算法，可以得到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&spm=1001.2101.3001.7020">最短路径</a>为：1 -&gt; 2 -&gt; 4 -&gt; 5，因此算出最短路径为2+2+1 &#x3D; 5。然而还存在一条路径即1 -&gt; 3 -&gt; 4 -&gt; 5，他的最短路径长度为5+(-2)+1&#x3D;4，因此Dijstra算法失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for n 次：</span><br><span class="line">  for 所有边 a , b , w （松弛操作）</span><br><span class="line">    dist[b] = min(dist[b], backup[a] + c)</span><br></pre></td></tr></table></figure>

<p>下面有一个有边数限制的最短路问题：</p>
<p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p>
<p>请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">510</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] backup = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">// 用于备份之前迭代的dist数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">// 从1号点到 n号点的距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node[] list = <span class="keyword">new</span> <span class="title class_">Node</span>[M]; <span class="comment">// 结构体</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n; <span class="comment">// 总点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> m; <span class="comment">// 总边数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> k; <span class="comment">// 最多经过k条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String[] str1 = bufferedReader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(str1[<span class="number">0</span>]);</span><br><span class="line">        m = Integer.parseInt(str1[<span class="number">1</span>]);</span><br><span class="line">        k = Integer.parseInt(str1[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">            String[] str2 = bufferedReader.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(str2[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(str2[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> Integer.parseInt(str2[<span class="number">2</span>]);</span><br><span class="line">            list[i] = <span class="keyword">new</span> <span class="title class_">Node</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bellman_ford();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bellman_ford</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">            <span class="comment">//备份dist数组</span></span><br><span class="line">            backup = Arrays.copyOf(dist, n + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> list[j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> node.x;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> node.y;</span><br><span class="line">                <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> node.z;</span><br><span class="line">                dist[y] = Math.min(dist[y], backup[x] + z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[n] &gt; INF / <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dist[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="dp题目"><a href="#dp题目" class="headerlink" title="dp题目"></a>dp题目</h2><h3 id="一、入门-DP"><a href="#一、入门-DP" class="headerlink" title="一、入门 DP"></a>一、入门 DP</h3><h3 id="二、网格图-DP"><a href="#二、网格图-DP" class="headerlink" title="二、网格图 DP"></a>二、网格图 DP</h3><p>问：如何思考循环顺序？什么时候要正序枚举，什么时候要倒序枚举？</p>
<p>答：这里有一个通用的做法：盯着状态转移方程，想一想，要计算 f[i] [j]，必须先把 f[i+1] [⋅]算出来，那么只有 i 从大到小枚举才能做到。对于 j来说，由于在计算 f[i] [j]的时候， f[i+1] [⋅]已经全部计算完毕，所以 j无论是正序还是倒序枚举都可以。</p>
<h3 id="2435-矩阵中和能被-K-整除的路径"><a href="#2435-矩阵中和能被-K-整除的路径" class="headerlink" title="2435. 矩阵中和能被 K 整除的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">2435. 矩阵中和能被 K 整除的路径</a></h3><p>定义 f[i] [j] [v] 表示从左上走到 (i,j)，且路径和模 k 的结果为 v 时的路径数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][][] f = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>][k];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">0</span>;v&lt;k;v++)&#123;</span><br><span class="line">                f[i+<span class="number">1</span>][j+<span class="number">1</span>][v+grid[i][j]%k]=(f[i + <span class="number">1</span>][j][v] + f[i][j + <span class="number">1</span>][v]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m][n][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dungeon-game/">174. 地下城游戏</a></h3><p>一句话，本题的难点在于怎么处理血量增加的问题, 增加血量不能为之前的损失提供帮助，只会对后续有帮助。<br>这意味着从王子救“＊＊＊”的思路想dp是困难的，但是“＊＊＊”救王子的思路dp很好做，从后往前推，当前如果可以治愈，那么当前的最小初始血量就是已经扣除的血量减去治疗量，注意不可以&lt;1。 这意味着过量治疗。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateMinimumHP</span><span class="params">(<span class="type">int</span>[][] dungeon)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dungeon.length, m = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n][m - <span class="number">1</span>] = dp[n - <span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">            dp[i][j] = Math.max(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="741-摘樱桃"><a href="#741-摘樱桃" class="headerlink" title="741. 摘樱桃"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/">741. 摘樱桃</a></h3><p><img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240428164330973.png" alt="image-20240428164330973"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cherryPickup</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">51</span>, INF = Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> [][][]dp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>*N][N][N];</span><br><span class="line">    <span class="type">int</span> n=grid.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;=<span class="number">2</span>*n ; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=n; j++) &#123;</span><br><span class="line">                dp[k][i][j]=INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>][<span class="number">1</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">3</span>;k&lt;=<span class="number">2</span>*n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">1</span>; i1 &lt;= n; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>; i2 &lt;= n; i2++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span> (j1 &lt;= <span class="number">0</span> || j1 &gt; n || j2 &lt;= <span class="number">0</span> || j2 &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> A=grid[i1-<span class="number">1</span>][j1-<span class="number">1</span>],B=grid[i2-<span class="number">1</span>][j2-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(A==-<span class="number">1</span>|B==-<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> dp[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2], b = dp[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>], c = dp[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>], d = dp[k - <span class="number">1</span>][i1][i2];</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Math.max(Math.max(a, b), Math.max(c, d)) + A;</span><br><span class="line">                <span class="keyword">if</span> (i1 != i2) t += B;</span><br><span class="line">                dp[k][i1][i2] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span> * n][n][n] &lt;= <span class="number">0</span> ? <span class="number">0</span> : dp[<span class="number">2</span> * n][n][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、背包"><a href="#三、背包" class="headerlink" title="三、背包"></a>三、背包</h3><h4 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h4><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png" alt="动态规划-背包问题2"></p>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程 dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]); 可以看出i 是由 i-<span class="number">1</span> 推导出来，那么i为<span class="number">0</span>的时候就一定要初始化。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png" alt="动态规划-背包问题5"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先遍历背包再遍历物品</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png" alt="动态规划-背包问题6"></p>
<h5 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<h4 id="完全背包理论基础"><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h4><p><strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><p>很少出现</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="四、经典线性-DP"><a href="#四、经典线性-DP" class="headerlink" title="四、经典线性 DP"></a>四、经典线性 DP</h3><h4 id="§4-1-最长公共子序列（LCS）"><a href="#§4-1-最长公共子序列（LCS）" class="headerlink" title="§4.1 最长公共子序列（LCS）"></a>§4.1 最长公共子序列（LCS）</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712. 两个字符串的最小ASCII删除和</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></p>
<h4 id="§4-2-最长递增子序列（LIS）"><a href="#§4-2-最长递增子序列（LIS）" class="headerlink" title="§4.2 最长递增子序列（LIS）"></a>§4.2 最长递增子序列（LIS）</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/300.png" alt="image-20240513232256413" style="zoom:80%;">

<p>关键在于d[i]的定义是长度为i的最长上升子序列的末尾元素最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常规做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> []dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result&lt;dp[i])result=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分加贪心做法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/">2111. 使数组 K 递增的最少操作次数</a></p>
<p>最长递增子序列变式 ,首先根据k进行分组，然后问题转化为求每一组中的最长非递减子序列的长度，用总长度减去子序列的长度即为调整次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kIncreasing</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;arr.length)&#123;   <span class="comment">//分组</span></span><br><span class="line">            temp.add(arr[j]);</span><br><span class="line">            j+=k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span>[temp.size()];</span><br><span class="line">         <span class="type">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : temp) &#123;           <span class="comment">//二分查找</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = maxLen;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low+(high-low)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[mid] &lt;= num)</span><br><span class="line">                    low = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[low] = num;      <span class="comment">//更新dp</span></span><br><span class="line">            <span class="keyword">if</span>(low == maxLen)</span><br><span class="line">                maxLen++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans+=temp.size()-maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></p>
<p>两个dp来分别维护最长数组长度 与到第i个结尾时一共有多少个最长的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> []dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//最长数组长度</span></span><br><span class="line"><span class="type">int</span> []count=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//到第i个结尾时一共有多少个最长的数组</span></span><br><span class="line"><span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) dp[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) count[i] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">            <span class="comment">//更新count数组</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                count[i]=count[j];</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(dp[j]+<span class="number">1</span>==dp[i])&#123;</span><br><span class="line">                count[i]+=count[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// dp[i]=Math.max(dp[i],dp[j]+1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxCount) maxCount = dp[i]; <span class="comment">// 记录最长长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCount == dp[i]) result += count[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/">1671. 得到山形数组的最少删除次数</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/1671.png" alt="image-20240513225431458" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumMountainRemovals</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] pre = getLISArray(nums);</span><br><span class="line">    <span class="type">int</span>[] reversed = reverse(nums);</span><br><span class="line">    <span class="type">int</span>[] suf = getLISArray(reversed);</span><br><span class="line">    suf = reverse(suf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i] &gt; <span class="number">1</span> &amp;&amp; suf[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, pre[i] + suf[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLISArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] reversed = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reversed[i] = nums[n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/">1964. 找出到每个位置为止最长的有效障碍赛跑路线</a></p>
<p>此题为最长递增子序列的二分法的应用，找到每次最长的index将其加入res 并实时维护a数组来表示第i长度递增序列的最小的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] longestObstacleCourseAtEachPosition(<span class="type">int</span>[] obstacles) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacles.length;</span><br><span class="line">        List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> [] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=obstacles[i];</span><br><span class="line">        <span class="type">int</span> index=binarysearch(a,num);</span><br><span class="line">        <span class="keyword">if</span>(index==a.size())a.add(num);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a.set(index,num);</span><br><span class="line">        &#125;</span><br><span class="line">        res[i]=index+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(List&lt;Integer&gt; a ,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=a.size();</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">            <span class="keyword">if</span>(a.get(mid)&gt;t)&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">2407. 最长递增子序列 II</a></p>
<p>在求解「上升子序列（IS）」问题时，一般有两种优化方法：</p>
<ol>
<li><p>维护固定长度的 IS 的末尾元素的最小值 + 二分优化；</p>
</li>
<li><p>基于<strong>值域</strong>的线段树、平衡树等数据结构优化。</p>
<p>此题使用线段树优化</p>
</li>
</ol>
<h3 id="五、状态机-DP"><a href="#五、状态机-DP" class="headerlink" title="五、状态机 DP"></a>五、状态机 DP</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></p>
<h3 id="六、划分型-DP"><a href="#六、划分型-DP" class="headerlink" title="六、划分型 DP"></a>六、划分型 DP</h3><h4 id="§6-1-判定能否划分"><a href="#§6-1-判定能否划分" class="headerlink" title="§6.1 判定能否划分"></a>§6.1 判定能否划分</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/">2369. 检查数组是否存在有效划分</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> dp[]=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ||</span><br><span class="line">                i &gt; <span class="number">1</span> &amp;&amp; dp[i - <span class="number">2</span>] &amp;&amp; (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] ||</span><br><span class="line">                        nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] + <span class="number">2</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="§6-2-计算划分个数"><a href="#§6-2-计算划分个数" class="headerlink" title="§6.2 计算划分个数"></a>§6.2 计算划分个数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCut</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][]array=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.length();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;=<span class="number">1</span>||array[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                array[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> []dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        dp[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>][i])&#123;</span><br><span class="line">            dp[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j+<span class="number">1</span>][i])&#123;</span><br><span class="line">                dp[i]=Math.min(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/extra-characters-in-a-string/">2707. 字符串中的额外字符</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minExtraChar</span><span class="params">(String s, String[] dictionary)</span> &#123;</span><br><span class="line">   <span class="type">int</span> n= s.length();</span><br><span class="line">       <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">       Map&lt;String,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String d:</span><br><span class="line">            dictionary) &#123;</span><br><span class="line">           map.put(d,map.getOrDefault(d,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">           dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span>(map.containsKey(s.substring(j,i)))&#123;</span><br><span class="line">                   dp[i]=Math.min(dp[i],dp[j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></p>
<p>其他细节：由于题目存在前导零，而前导零属于无效 item。可以进行特判，但个人习惯往字符串头部追加空格作为哨兵，追加空格既可以避免讨论前导零，也能使下标从 1 开始，简化 f[i-1] 等负数下标的判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="type">char</span> c[]=s.toCharArray();</span><br><span class="line">    <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span> [s.length()];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=c[i]-<span class="string">&#x27;0&#x27;</span>,b=(c[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+(c[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span>&lt;=a&amp;&amp;a&lt;=<span class="number">9</span>)dp[i]=dp[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">10</span>&lt;=b&amp;&amp;b&lt;=<span class="number">26</span>)dp[i]+=dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="§6-3-约束划分个数"><a href="#§6-3-约束划分个数" class="headerlink" title="§6.3 约束划分个数"></a>§6.3 约束划分个数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240522030445984.png" alt="image-20240522030445984" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算「子数组各自的和的最大值」的上下界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        max = Math.max(max, num);</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，</span></span><br><span class="line">    <span class="comment">// 使得它对应的「子数组的分割数」恰好等于 m</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> max;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">splits</span> <span class="operator">=</span> split(nums, mid);</span><br><span class="line">        <span class="keyword">if</span> (splits &gt; m) &#123;</span><br><span class="line">            <span class="comment">// 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大</span></span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 下一轮搜索的区间是上一轮的反面区间 [left, mid]</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxIntervalSum 子数组各自的和的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 满足不超过「子数组各自的和的最大值」的分割数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxIntervalSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 至少是一个分割</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">splits</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前区间的和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curIntervalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶</span></span><br><span class="line">        <span class="keyword">if</span> (curIntervalSum + num &gt; maxIntervalSum) &#123;</span><br><span class="line">            curIntervalSum = <span class="number">0</span>;</span><br><span class="line">            splits++;</span><br><span class="line">        &#125;</span><br><span class="line">        curIntervalSum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-array-for-maximum-sum/">1043. 分隔数组以得到最大和</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=arr.length;</span><br><span class="line">    <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i,max=<span class="number">0</span>;j&gt;i-k&amp;&amp;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">             max=Math.max(max,arr[j]);</span><br><span class="line">             dp[i+<span class="number">1</span>]=Math.max(dp[i+<span class="number">1</span>],dp[j]+(i-j+<span class="number">1</span>)*max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning-iv/">1745. 分割回文串 IV</a></p>
<p>此题思路和回文子串相同，用中心扩展法记录有多少个回文子串，然后遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPartitioning</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=s.length();</span><br><span class="line">    <span class="type">boolean</span> dp[][]=<span class="keyword">new</span> <span class="title class_">boolean</span> [n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            dp[l][r]=<span class="literal">true</span>;</span><br><span class="line">            --l;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>][i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j]&amp;&amp;dp[j+<span class="number">1</span>][n-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-sum-of-averages/">813. 最大平均值和的分组</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240522043611599.png" alt="image-20240522043611599" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">largestSumOfAverages</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    <span class="type">double</span> sum[]=<span class="keyword">new</span> <span class="title class_">double</span> [n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">double</span> dp[][]=<span class="keyword">new</span> <span class="title class_">double</span> [n+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum[i]=sum[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Math.min(i,k);j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>]=sum[i]/i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=i;l++)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i][j],dp[l-<span class="number">1</span>][j-<span class="number">1</span>]+(sum[i]-sum[l-<span class="number">1</span>])/(i-l+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="§6-4-不相交区间"><a href="#§6-4-不相交区间" class="headerlink" title="§6.4 不相交区间"></a>§6.4 不相交区间</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/">2830. 销售利润最大化</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximizeTheProfit</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; offers)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] groups = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">        Arrays.setAll(groups, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; offer:offers)&#123;</span><br><span class="line">            groups[offer.get(<span class="number">1</span>)].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;offer.get(<span class="number">0</span>),offer.get(<span class="number">2</span>)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> end=<span class="number">0</span>;end&lt;n;end++)&#123;</span><br><span class="line">            dp[end+<span class="number">1</span>]=dp[end];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[]group:groups[end])&#123;</span><br><span class="line">                dp[end+<span class="number">1</span>]=Math.max(dp[end+<span class="number">1</span>],dp[group[<span class="number">0</span>]]+group[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxTaxiEarnings</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] rides)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] groups = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] r : rides) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> r[<span class="number">0</span>], end = r[<span class="number">1</span>], tip = r[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (groups[end] == <span class="literal">null</span>) &#123;</span><br><span class="line">            groups[end] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        groups[end].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end - start + tip&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] f = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (groups[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] p : groups[i]) &#123;</span><br><span class="line">                f[i] = Math.max(f[i], f[p[<span class="number">0</span>]] + p[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxTaxiEarnings</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] rides)</span> &#123;</span><br><span class="line">        Arrays.sort(rides, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> rides.length;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarySearch1(rides, i, rides[i][<span class="number">0</span>]);</span><br><span class="line">            dp[i + <span class="number">1</span>] = Math.max(dp[i], dp[j] + rides[i][<span class="number">1</span>] - rides[i][<span class="number">0</span>] + rides[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[][] rides, <span class="type">int</span> right, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=low+(right-low)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(rides[mid][<span class="number">1</span>]&gt;target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">        <span class="type">int</span>[][] jobs = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            jobs[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class="line">        Arrays.sort(jobs, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]); <span class="comment">// 按照结束时间排序</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Search(jobs, i - <span class="number">1</span>, jobs[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[k] + jobs[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 endTime &lt;= upper 的最大下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Search</span><span class="params">(<span class="type">int</span>[][] jobs, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (jobs[mid][<span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、其它线性-DP"><a href="#七、其它线性-DP" class="headerlink" title="七、其它线性 DP"></a>七、其它线性 DP</h3><h4 id="§7-1-一维"><a href="#§7-1-一维" class="headerlink" title="§7.1 一维"></a>§7.1 一维</h4><h4 id="§7-2-特殊子序列"><a href="#§7-2-特殊子序列" class="headerlink" title="§7.2 特殊子序列"></a>§7.2 特殊子序列</h4><h4 id="§7-3-矩阵快速幂优化"><a href="#§7-3-矩阵快速幂优化" class="headerlink" title="§7.3 矩阵快速幂优化"></a>§7.3 矩阵快速幂优化</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> <span class="type">long</span>[][] mul(<span class="type">long</span>[][] a, <span class="type">long</span>[][] b) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> a.length, c = b[<span class="number">0</span>].length, z = b.length;</span><br><span class="line">     <span class="type">long</span>[][] ans = <span class="keyword">new</span> <span class="title class_">long</span>[r][c];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; z; k++) &#123;</span><br><span class="line">                 ans[i][j] += a[i][k] * b[k][j];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkRecord</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="type">long</span>[][] ans = <span class="keyword">new</span> <span class="title class_">long</span>[][]&#123;</span><br><span class="line">         &#123;<span class="number">1</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;, &#123;<span class="number">0</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="type">long</span>[][] mat = <span class="keyword">new</span> <span class="title class_">long</span>[][]&#123;</span><br><span class="line">         &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">         &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">         &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">         &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">         &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">         &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>) ans = mul(mat, ans);</span><br><span class="line">         mat = mul(mat, mat);</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">         res += ans[i][<span class="number">0</span>];</span><br><span class="line">         res %= mod;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;                    ans[i][j] %= mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-transformation/">2851. 字符串转换</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWays</span><span class="params">(String s, String t, <span class="type">long</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> kmpSearch(s + s.substring(<span class="number">0</span>, n - <span class="number">1</span>), t);<span class="comment">//避免统计最后一个字母</span></span><br><span class="line">        <span class="type">long</span>[][] m = &#123;</span><br><span class="line">            &#123;c - <span class="number">1</span>, c&#125;,</span><br><span class="line">            &#123;n - c, n - <span class="number">1</span> - c&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        m = pow(m, k);</span><br><span class="line">        <span class="keyword">return</span> s.equals(t) ? (<span class="type">int</span>) m[<span class="number">0</span>][<span class="number">0</span>] : (<span class="type">int</span>) m[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP 模板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] calcMaxMatch(String s) &#123;</span><br><span class="line">        <span class="type">int</span>[] match = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">v</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; s.charAt(c) != v) &#123;</span><br><span class="line">                c = match[c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(c) == v) &#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            match[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KMP 模板</span></span><br><span class="line">    <span class="comment">// 返回 text 中出现了多少次 pattern（允许 pattern 重叠）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] match = calcMaxMatch(pattern);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenP</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">matchCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">v</span> <span class="operator">=</span> text.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(c) != v) &#123;</span><br><span class="line">                c = match[c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(c) == v) &#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == lenP) &#123;</span><br><span class="line">                matchCnt++;</span><br><span class="line">                c = match[c - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[][] multiply(<span class="type">long</span>[][] a, <span class="type">long</span>[][] b) &#123;</span><br><span class="line">        <span class="type">long</span>[][] c = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = (a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵快速幂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span>[][] pow(<span class="type">long</span>[][] a, <span class="type">long</span> n) &#123;</span><br><span class="line">        <span class="type">long</span>[][] res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n /= <span class="number">2</span>) &#123;<span class="comment">//二分法求幂</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = multiply(res, a);</span><br><span class="line">            &#125;</span><br><span class="line">            a = multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、区间-DP"><a href="#八、区间-DP" class="headerlink" title="八、区间 DP"></a>八、区间 DP</h3><h4 id="§8-1-最长回文子序列"><a href="#§8-1-最长回文子序列" class="headerlink" title="§8.1 最长回文子序列"></a>§8.1 最长回文子序列</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [][]dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=s.length();i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))</span><br><span class="line">            dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-different-palindromic-subsequences/">730. 统计不同回文子序列</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPalindromicSubsequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>], R = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        Arrays.fill(L, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            L[cs[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">            Arrays.fill(R, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">                R[cs[j] - <span class="string">&#x27;a&#x27;</span>] = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (L[k] == -<span class="number">1</span> || R[k] == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> L[k], r = R[k];</span><br><span class="line">                    <span class="keyword">if</span> (l == r) f[i][j] = (f[i][j] + <span class="number">1</span>) % MOD;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (l == r - <span class="number">1</span>) f[i][j] = (f[i][j] + <span class="number">2</span>) % MOD;</span><br><span class="line">                    <span class="keyword">else</span> f[i][j] = (f[i][j] + f[l + <span class="number">1</span>][r - <span class="number">1</span>] + <span class="number">2</span>) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>s.length();</span><br><span class="line">    <span class="type">int</span> [][]dp=<span class="keyword">new</span> <span class="title class_">int</span> [n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="§8-2-其它区间-DP"><a href="#§8-2-其它区间-DP" class="headerlink" title="§8.2 其它区间 DP"></a>§8.2 其它区间 DP</h4><p>子串类型可以用中心扩散法优化时间</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></p>
<p>public String longestPalindrome(String s) {<br>        if (s &#x3D;&#x3D; null || s.length() &lt; 2) {<br>            return s;<br>        }<br>        int strLen &#x3D; s.length();<br>        int maxStart &#x3D; 0;  &#x2F;&#x2F;最长回文串的起点<br>        int maxEnd &#x3D; 0;    &#x2F;&#x2F;最长回文串的终点<br>        int maxLen &#x3D; 1;  &#x2F;&#x2F;最长回文串的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[strLen][strLen];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>; r &lt; strLen; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                    maxStart = l;</span><br><span class="line">                    maxEnd = r;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(maxStart, maxEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240526000548963.png" alt="image-20240526000548963" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii/">375. 猜数字大小 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>][n + <span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len - <span class="number">1</span>;</span><br><span class="line">            f[l][r] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l; x &lt;= r; x++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(f[l][x - <span class="number">1</span>], f[x + <span class="number">1</span>][r]) + x;</span><br><span class="line">                f[l][r] = Math.min(f[l][r], cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/burst-balloons/">312. 戳气球</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240526013617304.png" alt="image-20240526013617304" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) arr[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">3</span>; len &lt;= n + <span class="number">2</span>; len++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l + len - <span class="number">1</span> &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l + <span class="number">1</span>; k &lt;= r - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    f[l][r] = Math.max(f[l][r], f[l][k] + f[k][r] + arr[l] * arr[k] * arr[r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-to-merge-stones/">1000. 合并石头的最低成本</a></p>
<img src="https://pic.leetcode.cn/1680534488-qZHfMY-1000-3d-cut.png" alt="1000-3d-cut.png" style="zoom:67%;">

<img src="https://pic.leetcode.cn/1680534839-WSibYe-1000-2d.png" alt="1000-2d.png" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mergeStones</span><span class="params">(<span class="type">int</span>[] stones, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="keyword">if</span> ((n - <span class="number">1</span>) % (k - <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="comment">// 无法合并成一堆</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            s[i + <span class="number">1</span>] = s[i] + stones[i]; <span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i; m &lt; j; m += k - <span class="number">1</span>)</span><br><span class="line">                    f[i][j] = Math.min(f[i][j], f[i][m] + f[m + <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> ((j - i) % (k - <span class="number">1</span>) == <span class="number">0</span>) <span class="comment">// 可以合并成一堆</span></span><br><span class="line">                    f[i][j] += s[j + <span class="number">1</span>] - s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、状态压缩-DP（状压-DP）"><a href="#九、状态压缩-DP（状压-DP）" class="headerlink" title="九、状态压缩 DP（状压 DP）"></a>九、状态压缩 DP（状压 DP）</h3><h4 id="§9-1-排列型-①-相邻无关"><a href="#§9-1-排列型-①-相邻无关" class="headerlink" title="§9.1 排列型 ① 相邻无关"></a>§9.1 排列型 ① 相邻无关</h4><h4 id="§9-2-排列型-②-相邻相关"><a href="#§9-2-排列型-②-相邻相关" class="headerlink" title="§9.2 排列型 ② 相邻相关"></a>§9.2 排列型 ② 相邻相关</h4><h4 id="§9-3-旅行商问题（TSP）"><a href="#§9-3-旅行商问题（TSP）" class="headerlink" title="§9.3 旅行商问题（TSP）"></a>§9.3 旅行商问题（TSP）</h4><h4 id="§9-4-枚举子集的子集"><a href="#§9-4-枚举子集的子集" class="headerlink" title="§9.4 枚举子集的子集"></a>§9.4 枚举子集的子集</h4><h4 id="§9-5-其它状压-D"><a href="#§9-5-其它状压-D" class="headerlink" title="§9.5 其它状压 D"></a>§9.5 其它状压 D</h4><h3 id="十、数位-DP"><a href="#十、数位-DP" class="headerlink" title="十、数位 DP"></a>十、数位 DP</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-integers/">2719. 统计整数数目</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(String num1, String num2, <span class="type">int</span> minSum, <span class="type">int</span> maxSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        num1 = <span class="string">&quot;0&quot;</span>.repeat(n - num1.length()) + num1; <span class="comment">// 补前导零，和 num2 对齐</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][Math.min(<span class="number">9</span> * n, maxSum) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">true</span>, num1.toCharArray(), num2.toCharArray(), minSum, maxSum, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">boolean</span> limitLow, <span class="type">boolean</span> limitHigh, <span class="type">char</span>[] num1, <span class="type">char</span>[] num2, <span class="type">int</span> minSum, <span class="type">int</span> maxSum, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; maxSum) &#123; <span class="comment">// 非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == num2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum &gt;= minSum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!limitLow &amp;&amp; !limitHigh &amp;&amp; memo[i][sum] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][sum];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> limitLow ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> limitHigh ? num2[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> lo; d &lt;= hi; d++) &#123; <span class="comment">// 枚举当前数位填 d</span></span><br><span class="line">            res = (res + dfs(i + <span class="number">1</span>, sum + d, limitLow &amp;&amp; d == lo, limitHigh &amp;&amp; d == hi,</span><br><span class="line">                             num1, num2, minSum, maxSum, memo)) % <span class="number">1_000_000_007</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!limitLow &amp;&amp; !limitHigh) &#123;</span><br><span class="line">            memo[i][sum] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-2s-in-range-lcci/">面试题 17.06. 2出现的次数</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240530064021805.png" alt="image-20240530064021805" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[];</span><br><span class="line"><span class="type">int</span> dp[][];</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOf2sInRange</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s=Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="type">int</span> m=s.length;</span><br><span class="line">    dp=<span class="keyword">new</span> <span class="title class_">int</span> [m][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)Arrays.fill(dp[i],-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> count,<span class="type">boolean</span> islimit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==s.length)<span class="keyword">return</span> count;</span><br><span class="line">    <span class="keyword">if</span>(!islimit&amp;&amp;dp[i][count]&gt;=<span class="number">0</span>)<span class="keyword">return</span> dp[i][count];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,up=islimit?s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">9</span>;j&lt;=up;j++)&#123;</span><br><span class="line">        res+=dfs(i+<span class="number">1</span>,count+(j==<span class="number">2</span>?<span class="number">1</span>:<span class="number">0</span>),islimit&amp;&amp;j==up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!islimit)dp[i][count]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] digits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> s[];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> dp[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">atMostNGivenDigitSet</span><span class="params">(String[] digits, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.digits = digits;</span><br><span class="line">        s = Integer.toString(n).toCharArray();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length];</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>); <span class="comment">// dp[i] = -1 表示 i 这个状态还没被计算出来</span></span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> isNum ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果填了数字，则为 1 种合法方案</span></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; dp[i] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[i]; <span class="comment">// 在不受到任何约束的情况下，返回记录的结果，避免重复运算</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isNum) <span class="comment">// 前面不填数字，那么可以跳过当前数位，也不填数字</span></span><br><span class="line">            <span class="comment">// isLimit 改为 false，因为没有填数字，位数都比 n 要短，自然不会受到 n 的约束</span></span><br><span class="line">            <span class="comment">// isNum 仍然为 false，因为没有填任何数字</span></span><br><span class="line">            res = f(i + <span class="number">1</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] : <span class="string">&#x27;9&#x27;</span>; <span class="comment">// 根据是否受到约束，决定可以填的数字的上限</span></span><br><span class="line">        <span class="comment">// 注意：对于一般的题目而言，如果此时 isNum 为 false，则必须从 1 开始枚举，由于本题 digits 没有 0，所以无需处理这种情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> d : digits) &#123; <span class="comment">// 枚举要填入的数字 d</span></span><br><span class="line">            <span class="keyword">if</span> (d.charAt(<span class="number">0</span>) &gt; up) <span class="keyword">break</span>; <span class="comment">// d 超过上限，由于 digits 是有序的，后面的 d 都会超过上限，故退出循环</span></span><br><span class="line">            <span class="comment">// isLimit：如果当前受到 n 的约束，且填的数字等于上限，那么后面仍然会受到 n 的约束</span></span><br><span class="line">            <span class="comment">// isNum 为 true，因为填了数字</span></span><br><span class="line">            res += f(i + <span class="number">1</span>, isLimit &amp;&amp; d.charAt(<span class="number">0</span>) == up, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum) dp[i] = res; <span class="comment">// 在不受到任何约束的情况下，记录结果</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="十一、数据结构优化-DP"><a href="#十一、数据结构优化-DP" class="headerlink" title="十一、数据结构优化 DP"></a>十一、数据结构优化 DP</h3><h3 id="十二、树形-DP"><a href="#十二、树形-DP" class="headerlink" title="十二、树形 DP"></a>十二、树形 DP</h3><h4 id="§12-1-树的直径"><a href="#§12-1-树的直径" class="headerlink" title="§12.1 树的直径"></a>§12.1 树的直径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        dfs1(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> root.left == <span class="literal">null</span>? <span class="number">0</span>: dfs1(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> root.right == <span class="literal">null</span>? <span class="number">0</span>: dfs1(root.right) + <span class="number">1</span>;</span><br><span class="line">    max=Math.max(max,leftSize+rightSize);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftSize,rightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxsum=Integer.MIN_VALUE;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> leftgain=Math.max(dfs(root.left),<span class="number">0</span>);</span><br><span class="line">       <span class="type">int</span> rightgain=Math.max(dfs(root.right),<span class="number">0</span>);</span><br><span class="line">       <span class="type">int</span> sum=root.val+leftgain+rightgain;</span><br><span class="line">       maxsum=Math.max(sum,maxsum);</span><br><span class="line">       <span class="keyword">return</span> root.val + Math.max(leftgain, rightgain);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">2246. 相邻字符不同的最长路径</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] g;</span><br><span class="line"> String s;</span><br><span class="line"> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPath</span><span class="params">(<span class="type">int</span>[] parent, String s)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.s = s;</span><br><span class="line">     <span class="type">var</span> <span class="variable">n</span> <span class="operator">=</span> parent.length;</span><br><span class="line">     g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line">     Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) g[parent[i]].add(i);</span><br><span class="line"></span><br><span class="line">     dfs(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="type">var</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> y : g[x]) &#123;</span><br><span class="line">         <span class="type">var</span> <span class="variable">len</span> <span class="operator">=</span> dfs(y) + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (s.charAt(y) != s.charAt(x)) &#123;</span><br><span class="line">             ans = Math.max(ans, maxLen + len);</span><br><span class="line">             maxLen = Math.max(maxLen, len);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> maxLen;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="§12-2-树上最大独立集"><a href="#§12-2-树上最大独立集" class="headerlink" title="§12.2 树上最大独立集"></a>§12.2 树上最大独立集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = robAction1(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span>[] robAction1(TreeNode root) &#123;</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> []left=robAction1(root.left);</span><br><span class="line">        <span class="type">int</span> []right=robAction1(root.right);</span><br><span class="line">        res[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">        res[<span class="number">1</span>]=root.val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="§12-3-树上最小支配集"><a href="#§12-3-树上最小支配集" class="headerlink" title="§12.3 树上最小支配集"></a>§12.3 树上最小支配集</h4><p>0:安装摄像头</p>
<p>1：不安装摄像头但是父节点安装摄像头<br>2：不安装摄像头但是儿子节点安装摄像头</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res = dfs(root);</span><br><span class="line">    <span class="keyword">return</span> Math.min(res[<span class="number">0</span>], res[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Integer.MAX_VALUE / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 除 2 防止加法溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] left = dfs(node.left);</span><br><span class="line">    <span class="type">int</span>[] right = dfs(node.right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">choose</span> <span class="operator">=</span> Math.min(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.min(right[<span class="number">0</span>], right[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">byFa</span> <span class="operator">=</span> Math.min(left[<span class="number">0</span>], left[<span class="number">2</span>]) + Math.min(right[<span class="number">0</span>], right[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">byChildren</span> <span class="operator">=</span> Math.min(Math.min(left[<span class="number">0</span>] + right[<span class="number">2</span>], left[<span class="number">2</span>] + right[<span class="number">0</span>]), left[<span class="number">0</span>] + right[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;choose, byFa, byChildren&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P2458">SDOI2006保安站岗</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;p=p*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> f*p;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1503</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> from,to;</span><br><span class="line">&#125;p[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,cnt,head[maxn&lt;&lt;<span class="number">1</span>],val[maxn];</span><br><span class="line"><span class="type">int</span> f[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//设状态f[x][0],f[x][1],f[x][2]分别表示</span></span><br><span class="line"><span class="comment">//对于x点,被自己覆盖,被自己的儿子覆盖,被自己的父亲覆盖时</span></span><br><span class="line"><span class="comment">//满足以x为根的子树所有点都被覆盖的最小代价 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//加边 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	p[cnt].from=head[x];</span><br><span class="line">	head[x]=cnt;</span><br><span class="line">	p[cnt].to=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TreeDP</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span><span class="comment">//树形DP </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x][<span class="number">0</span>]=val[x];<span class="comment">//初值:选择x点 </span></span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,must_need_mincost=inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=p[i].from)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> y=p[i].to;</span><br><span class="line">			<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">TreeDP</span>(y,x);</span><br><span class="line">			<span class="type">int</span> t=<span class="built_in">min</span>(f[y][<span class="number">0</span>],f[y][<span class="number">1</span>]);</span><br><span class="line">			f[x][<span class="number">0</span>]+=<span class="built_in">min</span>(t,f[y][<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">//自己被自己覆盖:儿子怎么样都行 </span></span><br><span class="line">			f[x][<span class="number">2</span>]+=t;</span><br><span class="line">            <span class="comment">//自己被父节点覆盖:儿子必须合法,要么选择儿子,要么是儿子被儿子的儿子覆盖 </span></span><br><span class="line">			<span class="comment">//以下是对f[x][1]的转移，请好好理解 </span></span><br><span class="line">			<span class="keyword">if</span>(f[y][<span class="number">0</span>]&lt;f[y][<span class="number">1</span>])sum++;</span><br><span class="line">            <span class="comment">//如果选择儿子节点更优,选上,计数器sum++，证明选过f[y][0] </span></span><br><span class="line">			<span class="keyword">else</span> must_need_mincost=<span class="built_in">min</span>(must_need_mincost,f[y][<span class="number">0</span>]-f[y][<span class="number">1</span>]);</span><br><span class="line">			<span class="comment">//否则记录一个最小的必须支付代价</span></span><br><span class="line">            <span class="comment">//因为最后要保证x点被y覆盖,必须要找差值最小的,这样才最优 </span></span><br><span class="line">			f[x][<span class="number">1</span>]+=t;<span class="comment">//自己被儿子覆盖,那么儿子必须合法 </span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(!sum)f[x][<span class="number">1</span>]+=must_need_mincost;</span><br><span class="line">	<span class="comment">//对于f[x][1]转移:如果一个f[y][0]都没选过,那么必须从差值最小的儿子里面选择一个 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">			val[x]=<span class="built_in">read</span>();</span><br><span class="line">			<span class="type">int</span> num=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">while</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> y=<span class="built_in">read</span>();</span><br><span class="line">					<span class="built_in">add_edge</span>(x,y);</span><br><span class="line">					<span class="built_in">add_edge</span>(y,x);</span><br><span class="line">					num--;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">TreeDP</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(f[<span class="number">1</span>][<span class="number">0</span>],f[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="comment">//由于根节点没有父节点,最后答案就是min(f[1][0],f[1][1])</span></span><br><span class="line">	<span class="comment">//即1节点被自己覆盖或者被自己的儿子覆盖 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="§12-4-换根-DP"><a href="#§12-4-换根-DP" class="headerlink" title="§12.4 换根 DP"></a>§12.4 换根 DP</h4><img src="https://pic.leetcode.cn/1689398667-omjvbD-lc834.png" alt="lc834.png" style="zoom:67%;">

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-distances-in-tree/">834. 树中距离之和</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] ans, size;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sumOfDistancesInTree(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n]; <span class="comment">// g[x] 表示 x 的所有邻居</span></span><br><span class="line">    Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> [] e : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">        g[x].add(y);</span><br><span class="line">        g[y].add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dfs(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 0 没有父节点</span></span><br><span class="line">    reroot(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 0 没有父节点</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        ans[<span class="number">0</span>] += depth; <span class="comment">// depth 为 0 到 x 的距离</span></span><br><span class="line">        size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123; <span class="comment">// 遍历 x 的邻居 y</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123; <span class="comment">// 避免访问父节点</span></span><br><span class="line">                dfs(y, x, depth + <span class="number">1</span>); <span class="comment">// x 是 y 的父节点</span></span><br><span class="line">                size[x] += size[y]; <span class="comment">// 累加 x 的儿子 y 的子树大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123; <span class="comment">// 遍历 x 的邻居 y</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123; <span class="comment">// 避免访问父节点</span></span><br><span class="line">                ans[y] = ans[x] + g.length - <span class="number">2</span> * size[y];</span><br><span class="line">                reroot(y, x); <span class="comment">// x 是 y 的父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/">2581. 统计可能的树根数目</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] times;</span><br><span class="line">   <span class="keyword">private</span> Set&lt;Long&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> k, res, cnt0;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rootCount</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[][] guesses, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.k = k;</span><br><span class="line">       times = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">           Arrays.setAll(times, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> e[<span class="number">1</span>];</span><br><span class="line">               times[x].add(y);</span><br><span class="line">               times[y].add(x); <span class="comment">// 建图</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span>[] e : guesses) &#123; <span class="comment">// guesses 转成哈希表</span></span><br><span class="line">               s.add((<span class="type">long</span>) e[<span class="number">0</span>] &lt;&lt; <span class="number">32</span> | e[<span class="number">1</span>]); <span class="comment">// 两个 4 字节 int 压缩成一个 8 字节 long</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">           reroot(<span class="number">0</span>, -<span class="number">1</span>, cnt0);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> y : times[x]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (s.contains((<span class="type">long</span>) x &lt;&lt; <span class="number">32</span> | y)) &#123; <span class="comment">// 以 0 为根时，猜对了</span></span><br><span class="line">                       cnt0++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   dfs(y, x);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (cnt &gt;= k) &#123; <span class="comment">// 此时 cnt 就是以 x 为根时的猜对次数</span></span><br><span class="line">               res++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> y : times[x]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cnt;</span><br><span class="line">                   <span class="keyword">if</span> (s.contains((<span class="type">long</span>) x &lt;&lt; <span class="number">32</span> | y)) c--; <span class="comment">// 原来是对的，现在错了</span></span><br><span class="line">                   <span class="keyword">if</span> (s.contains((<span class="type">long</span>) y &lt;&lt; <span class="number">32</span> | x)) c++; <span class="comment">// 原来是错的，现在对了</span></span><br><span class="line">                   reroot(y, x, c);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的建立"><a href="#图的建立" class="headerlink" title="图的建立"></a>图的建立</h2><p>链式前向星——最完美图解</p>
<p>图的存储方法很多，最常见的除了邻接矩阵、邻接表和边集数组外，还有链式前向星。链式前向星是一种静态链表存储，用边集数组和邻接表相结合，可以快速访问一个顶点的所有邻接点，在算法竞赛中广泛应用。</p>
<p>链式前向星存储包括两种结构：</p>
<ol>
<li>边集数组：edge[ ]，edge[i]表示第i条边；</li>
<li>头结点数组：head[ ]，head[i]存以i为起点的第一条边的下标(在edge[]中的下标)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edge[maxe];<span class="comment">//边集数组，边数一般要设置比maxn*maxn大的数，如果题目有要求除外</span></span><br><span class="line"></span><br><span class="line">int head[maxn];<span class="comment">//头结点数组</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>每一条边的结构，如图所示。     </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/9dc2e1487aa9aba63f1a44319471e683.png" alt="img"></p>
<p>例如，一个无向图，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/c57f31f17f706c9bf90cfca384e8437d.png" alt="img"></p>
<p>按以下顺序输入每条边的两个端点，建立的链式前向星，过程如下。</p>
<ol>
<li>输入 1 2 5</li>
</ol>
<p>创建一条边1—2，权值为5，创建第一条边edge[0]，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/58262059065813797b91b846a21857b9.png" alt="img"></p>
<p>然后将该边链接到1号结点的头结点中。（初始时head[]数组全部初始化为-1）</p>
<p>即edge[0].next&#x3D;head[1]; head[1]&#x3D;0; 表示1号结点关联的第一个条边为0号边，如图所示。图中的虚线箭头仅表示他们之间的链接关系，不是指针。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/67314638d022f057e46a0a5331d98bf6.png" alt="img"></p>
<p>因为是无向图，还需要添加它的反向边，2—1，权值为5。创建第二条边edge[1]，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/1f065ca28d2c1ac76f8efac1f61be0a8.png" alt="img"></p>
<p>然后将该边链接到2号结点的头结点中。</p>
<p>即edge[1].next&#x3D;head[2]; head[2]&#x3D;1; 表示2号结点关联的第一个条边为1号边，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/1747b4d7cada1a435b8fd711333d1b82.png" alt="img"></p>
<ol>
<li>输入 1 4 3</li>
</ol>
<p>创建一条边1—4，权值为3，创建第3条边edge[2]，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/413f5fba355d25e2f47f381d271b01cf.png" alt="img"></p>
<p>然后将该边链接到1号结点的头结点中（头插法）。</p>
<p>即edge[2].next&#x3D;head[1]; head[1]&#x3D;2; 表示1号结点关联的第一个条边为2号边，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/ad272c2be376af3e97c3b3829ea65bd0.png" alt="img"></p>
<p>因为是无向图，还需要添加它的反向边，4—1，权值为3。创建第4条边edge[3]，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/4f126a11e34344a58d0c7c2bbef095e5.png" alt="img"></p>
<p>然后将该边链接到4号结点的头结点中。</p>
<p>即edge[3].next&#x3D;head[4]; head[4]&#x3D;3; 表示4号结点关联的第一个条边为3号边，如图所示。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/c2ae47c1e48d3f511a022cba2b20205c.png" alt="img"></p>
<ol>
<li>依次输入以下三条边，创建的链式前向星，如图所示。</li>
</ol>
<p>​         2 3 8</p>
<p>​         2 4 12</p>
<p>​         3 4 9</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/4fb54a64519b69eafd6a16557401c47b.png" alt="img"></p>
<p>添加一条边u v w的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span>(<span class="params">int u,int v,int w</span>)&#123;<span class="comment">//添加一条边</span></span><br><span class="line">    edge[cnt].<span class="property">to</span>=v;</span><br><span class="line">    edge[cnt].<span class="property">w</span>=w;</span><br><span class="line">    edge[cnt].<span class="property">next</span>=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>如果是有向图，每输入一条边，执行一次add(u,v,w)即可；如果是无向图，则需要执行两次add(u,v,w); add(v,u,w)。</p>
<p><strong>如何使用链式前向星访问一个结点u的所有邻接点呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=head[u];i!=-<span class="number">1</span>;i=edge[i].<span class="property">next</span>)&#123;</span><br><span class="line">    int v=edge[i].<span class="property">to</span>; <span class="comment">//u的邻接点</span></span><br><span class="line">    int w=edge[i].<span class="property">w</span>; <span class="comment">//u—v的权值</span></span><br><span class="line">       …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><strong>链式前向星的特性：</strong></p>
<ol>
<li>和邻接表一样，因为采用头插法进行链接，所以边输入顺序不同，创建的链式前向星也不同。</li>
<li>对于无向图，每输入一条边，需要添加两条边，互为反向边。例如，输入第一条边1 2 5，实际上添加了两条边，如图所示。</li>
</ol>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2934367/6a91acbb17d5f6a0033c92c07e301fc5.png" alt="img"></p>
<p>这两条边可以通过互为反向边，可以通过与1的异或运算得到其反向边，0^1&#x3D;1，1^1&#x3D;0。也就是说如果一条边的下标为i，则其反向边为i^1。这个特性应用在网络流中非常方便。</p>
<p>3.链式前向星具有边集数组和邻接表的功能，属于静态链表，不需要频繁地创建结点，应用十分灵活。</p>
<p><strong>总代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//创建无向网的链式前向星 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> maxx[maxn],head[maxn];</span><br><span class="line"><span class="type">int</span> n,m,x,y,w,cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,w,next;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;<span class="comment">//添加一条边u--v </span></span><br><span class="line"> 	e[cnt].to=v;</span><br><span class="line"> 	e[cnt].w=w;</span><br><span class="line">	e[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt++;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printg</span><span class="params">()</span></span>&#123;<span class="comment">//输出链式前向星</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;----------链式前向星如下：----------&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line">		cout&lt;&lt;v&lt;&lt;<span class="string">&quot;：  &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[v];~i;i=e[i].next)&#123;</span><br><span class="line">			<span class="type">int</span> v1=e[i].to,w1=e[i].w;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;v1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w1&lt;&lt;<span class="string">&quot;]\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">		<span class="built_in">add</span>(x,y,w);<span class="comment">//添加边</span></span><br><span class="line">		<span class="built_in">add</span>(y,x,w);<span class="comment">//添加反向边 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printg</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输入样例</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2 5</span></span><br><span class="line"><span class="comment">1 4 3</span></span><br><span class="line"><span class="comment">2 3 8</span></span><br><span class="line"><span class="comment">2 4 12</span></span><br><span class="line"><span class="comment">3 4 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="线段树的建立"><a href="#线段树的建立" class="headerlink" title="线段树的建立"></a>线段树的建立</h3><p>如果题目中给了具体的区间范围，我们根据该范围建立线段树。见题目 区域和检索 - 数组可修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">        node.val = arr[start];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildTree(node.left, start, mid);</span><br><span class="line">    buildTree(node.right, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="comment">// 向上更新</span></span><br><span class="line">    pushUp(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上更新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    node.val = node.left.val + node.right.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是很多时候，题目中都没有给出很具体的范围，只有数据的取值范围，一般都很大，所以我们更常用的是「动态开点」</p>
<p>下面我们手动模拟一下「动态开点」的过程。同样的，也是基于上面的例子 nums &#x3D; [1, 2, 3, 4, 5]</p>
<p>假设一种情况，最开始只知道数组的长度 5，而不知道数组内每个元素的大小，元素都是后面添加进去的。所以线段树的初始状态如下图所示：(只有一个节点，很孤独！！)</p>
<p><img src="https://pic.leetcode-cn.com/1655808248-EfPSRV-1.svg" alt="1.svg"></p>
<p>假设此时，我们添加了一个元素 [2, 2]; val &#x3D; 3。现在线段树的结构如下图所示：</p>
<p><img src="https://pic.leetcode-cn.com/1655808231-VTJvAM-2.svg" alt="2.svg"></p>
<p>这里需要解释一下，如果一个节点没有左右孩子，会一下子把左右孩子节点都给创建出来，如上图橙色节点所示，具体代码可见方法 pushDown()</p>
<p>两个橙色的叶子节点仅仅只是被创建出来了，并无实际的值，均为 0；而另外一个橙色的非叶子节点，值为 3 的原因是下面的孩子节点的值向上更新得到的</p>
<p>下面给出依次添加剩余节点的过程：(注意观察值的变化！！)</p>
<p><img src="https://pic.leetcode-cn.com/1655808224-kMYiyq-3.svg" alt="3.svg"></p>
<p>线段树的更新<br>我看大多数教程都是把更新分为两种：「点更新」和「区间更新」。其实这两种可以合并成一种，「点更新」不就是更新长度为 1 的区间嘛！！</p>
<p>更新区间的前提是找到需要更新的区间，所以和查询的思路很相似</p>
<p>如果我们要把区间 [2, 4] 内的元素都「➕1」</p>
<p><img src="https://pic.leetcode-cn.com/1654588378-Bhkpkc-3.svg" alt="3.svg"></p>
<p>当我们向孩子节点遍历的时候会把「懒惰标记」下推给孩子节点</p>
<p>我们需要稍微修改一下 Node 的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 左右孩子节点</span></span><br><span class="line">    Node left, right;</span><br><span class="line">    <span class="comment">// 当前节点值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 懒惰标记</span></span><br><span class="line">    <span class="type">int</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于「动态开点」的前提，我们下推懒惰标记的时候，如果节点不存在左右孩子节点，那么我们就创建左右孩子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> * <span class="meta">@Description</span>: 线段树（动态开点）</span><br><span class="line"></span><br><span class="line">   * <span class="meta">@Author</span>: LFool</span><br><span class="line">   * <span class="meta">@Date</span> <span class="number">2022</span>/<span class="number">6</span>/<span class="number">7</span> 09:<span class="number">15</span></span><br><span class="line">     **/</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTreeDynamic</span> &#123;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">         Node left, right;</span><br><span class="line">         <span class="type">int</span> val, add;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">     <span class="comment">// 下面来实现更新的函数：</span></span><br><span class="line">     <span class="comment">// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val</span></span><br><span class="line">     <span class="comment">// 对于上面的例子，应该这样调用该函数：update(root, 0, 4, 2, 4, 1)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="comment">// 找到满足要求的区间</span></span><br><span class="line">       <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">           <span class="comment">// 区间节点加上更新值</span></span><br><span class="line">           <span class="comment">// 注意：需要✖️该子树所有叶子节点</span></span><br><span class="line">           node.val += (end - start + <span class="number">1</span>) * val;</span><br><span class="line">           <span class="comment">// 添加懒惰标记</span></span><br><span class="line">           <span class="comment">// 对区间进行「加减」的更新操作，懒惰标记需要累加，不能直接覆盖</span></span><br><span class="line">           node.add += val;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 下推标记</span></span><br><span class="line">       <span class="comment">// mid - start + 1：表示左孩子区间叶子节点数量</span></span><br><span class="line">       <span class="comment">// end - mid：表示右孩子区间叶子节点数量</span></span><br><span class="line">       pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">       <span class="comment">// [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间</span></span><br><span class="line">       <span class="keyword">if</span> (l &lt;= mid) update(node.left, start, mid, l, r, val);</span><br><span class="line">       <span class="comment">// [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间</span></span><br><span class="line">       <span class="keyword">if</span> (r &gt; mid) update(node.right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">       <span class="comment">// 向上更新</span></span><br><span class="line">       pushUp(node);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//线段树的查询       </span></span><br><span class="line">   <span class="comment">// 在区间 [start, end] 中查询区间 [l, r] 的结果，即 [l ,r] 保持不变</span></span><br><span class="line">   <span class="comment">// 对于上面的例子，应该这样调用该函数：query(root, 0, 4, 2, 4)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 区间 [l ,r] 完全包含区间 [start, end]</span></span><br><span class="line">    <span class="comment">// 例如：[2, 4] = [2, 2] + [3, 4]，当 [start, end] = [2, 2] 或者 [start, end] = [3, 4]，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="keyword">return</span> node.val;</span><br><span class="line">    <span class="comment">// 把当前区间 [start, end] 均分得到左右孩子的区间范围</span></span><br><span class="line">    <span class="comment">// node 左孩子区间 [start, mid]</span></span><br><span class="line">    <span class="comment">// node 左孩子区间 [mid + 1, end]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下推标记</span></span><br><span class="line">    pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">    <span class="comment">// [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) ans += query(node.left, start, mid, l, r);</span><br><span class="line">    <span class="comment">// [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) ans += query(node.right, mid + <span class="number">1</span>, end, l, r);</span><br><span class="line">    <span class="comment">// ans 把左右子树的结果都累加起来了，与树的后续遍历同理</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向上更新</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">       node.val = node.left.val + node.right.val;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//先来实现下推懒惰标记的函数：</span></span><br><span class="line"><span class="comment">// leftNum 和 rightNum 表示左右孩子区间的叶子节点数量</span></span><br><span class="line"><span class="comment">// 因为如果是「加减」更新操作的话，需要用懒惰标记的值✖️叶子节点的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node node, <span class="type">int</span> leftNum, <span class="type">int</span> rightNum)</span> &#123;</span><br><span class="line">    <span class="comment">// 动态开点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span>) node.left = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="literal">null</span>) node.right = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 如果 add 为 0，表示没有标记</span></span><br><span class="line">    <span class="keyword">if</span> (node.add == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 注意：当前节点加上标记值✖️该子树所有叶子节点的数量</span></span><br><span class="line">    node.left.val += node.add * leftNum;</span><br><span class="line">    node.right.val += node.add * rightNum;</span><br><span class="line">    <span class="comment">// 把标记下推给孩子节点</span></span><br><span class="line">    <span class="comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span></span><br><span class="line">    node.left.add += node.add;</span><br><span class="line">    node.right.add += node.add;</span><br><span class="line">    <span class="comment">// 取消当前节点标记</span></span><br><span class="line">    node.add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2407-最长递增子序列-II-力扣（LeetCode）"><a href="#2407-最长递增子序列-II-力扣（LeetCode）" class="headerlink" title="2407. 最长递增子序列 II - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/solutions/1816920/by-lfool-f6vs/">2407. 最长递增子序列 II - 力扣（LeetCode）</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 查询区间 [nums[i] - k, nums[i] - 1] 的最值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> query(root, <span class="number">0</span>, N, Math.max(<span class="number">0</span>, nums[i] - k), nums[i] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 更新，注意这里是覆盖更新，对应的模版中覆盖更新不需要累加，已在下方代码中标注</span></span><br><span class="line">            update(root, <span class="number">0</span>, N, nums[i], nums[i], cnt);</span><br><span class="line">            ans = Math.max(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// *************** 下面是模版 ***************</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="type">int</span> val, add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            node.val = val; <span class="comment">// 不需要累加</span></span><br><span class="line">            node.add = val; <span class="comment">// 不需要累加</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) update(node.left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) update(node.right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        pushUp(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="keyword">return</span> node.val;</span><br><span class="line">        pushDown(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans = query(node.left, start, mid, l, r);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) ans = Math.max(ans, query(node.right, mid + <span class="number">1</span>, end, l, r));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.val = Math.max(node.left.val, node.right.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) node.left = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) node.right = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">if</span> (node.add == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        node.left.val = node.add;  <span class="comment">// 不需要累加</span></span><br><span class="line">        node.right.val = node.add; <span class="comment">// 不需要累加</span></span><br><span class="line">        node.left.add = node.add;  <span class="comment">// 不需要累加</span></span><br><span class="line">        node.right.add = node.add; <span class="comment">// 不需要累加</span></span><br><span class="line">        node.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><img src="https://pic.leetcode-cn.com/1649014227-ofNuJc-image.png" alt="image.png"></p>
<p><img src="https://pic.leetcode-cn.com/1649015091-pyEACj-image.png" alt="image.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] _nums)</span> &#123;</span><br><span class="line">        nums = _nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        add(i + <span class="number">1</span>, val - nums[i]);</span><br><span class="line">        nums[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(r + <span class="number">1</span>) - query(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="comment">// 上来先把三个方法写出来</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询前缀和的方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowbit(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在树状数组 x 位置中增加值 u</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowbit(i)) tree[i] += u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化「树状数组」，要默认数组是从 1 开始</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) add(i + <span class="number">1</span>, nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用「树状数组」：</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span></span><br><span class="line">        add(i + <span class="number">1</span>, val - nums[i]); </span><br><span class="line">        nums[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> query(r + <span class="number">1</span>) - query(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/">3072. 将元素分配到两个数组中 II</a></p>
<p>根据题意，要实现 greaterCount 函数，需要快速查找一个有序结构中，严格大于 val 的元素数量。我们可以使用「树状数组」来实现这个数据结构，其它「线段树」结构也可以实现相同功能。</p>
<p>首先，因为我们只关心数组元素的大小关系，我们可以将数组「离散化」。</p>
<p>然后我们根据题意进行模拟，初始化两个数组和其对应的树，依次遍历原数组中的元素，根据题目条件，将元素加入到对应数组中，并将元素离散化后的数组索引加入到树中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeArrays</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> []tree;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeArrays</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        tree=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;tree.length)&#123;</span><br><span class="line">            tree[i]++;</span><br><span class="line">            i+=i&amp;-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res+=tree[i];</span><br><span class="line">            i-=i&amp;-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] resultArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] sortedNums = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            index.put(sortedNums[i], i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arr1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(nums[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Integer&gt; arr2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(nums[<span class="number">1</span>]));</span><br><span class="line">        <span class="type">TreeArrays</span> <span class="variable">tree1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeArrays</span>(n);</span><br><span class="line">        <span class="type">TreeArrays</span> <span class="variable">tree2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeArrays</span>(n);</span><br><span class="line">        tree1.add(index.get(nums[<span class="number">0</span>]));</span><br><span class="line">        tree2.add(index.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> arr1.size() - tree1.get(index.get(nums[i]));</span><br><span class="line">            <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> arr2.size() - tree2.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr1.size() &lt;= arr2.size())) &#123;</span><br><span class="line">                arr1.add(nums[i]);</span><br><span class="line">                tree1.add(index.get(nums[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.add(nums[i]);</span><br><span class="line">                tree2.add(index.get(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a: arr1) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a: arr2) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、堆（优先队列）"><a href="#五、堆（优先队列）" class="headerlink" title="五、堆（优先队列）"></a>五、堆（优先队列）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">2530. 执行 K 次操作后的最大分数</a></p>
<p>自己写一个堆排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxKelements</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    buildheap(nums); <span class="comment">// 原地堆化（最大堆）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += nums[<span class="number">0</span>]; <span class="comment">// 堆顶</span></span><br><span class="line">        nums[<span class="number">0</span>] = (nums[<span class="number">0</span>] + <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">        sink(nums, <span class="number">0</span>); <span class="comment">// 堆化（只需要把 nums[0] 下沉）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildheap</span><span class="params">(<span class="type">int</span> []num)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=num.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        sink(num,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> []arr,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">int</span> length=arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftChild</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//左子节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightChild</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">//右子节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">present</span> <span class="operator">=</span> index;<span class="comment">//要调整的节点下标</span></span><br><span class="line">     <span class="comment">//下沉左边</span></span><br><span class="line"><span class="keyword">if</span> (leftChild &lt; length &amp;&amp; arr[leftChild] &gt; arr[present]) &#123;</span><br><span class="line">    present = leftChild;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下沉右边</span></span><br><span class="line"><span class="keyword">if</span> (rightChild &lt; length &amp;&amp; arr[rightChild] &gt; arr[present]) &#123;</span><br><span class="line">    present = rightChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line"><span class="keyword">if</span> (present != index) &#123;</span><br><span class="line">    <span class="comment">//交换值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">    arr[index] = arr[present];</span><br><span class="line">    arr[present] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续下沉 在取出头元素后与尾元素交换继续下沉</span></span><br><span class="line">    sink(arr, present);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-threaded-cpu/">1834. 单线程 CPU</a></p>
<p>三个参数排序，先按照到达时间排序，再按照执行时间排序，最后再按照到达顺序排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getOrder(<span class="type">int</span>[][] tasks) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>tasks.length;</span><br><span class="line">        <span class="type">int</span> [][]list=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list[i]=<span class="keyword">new</span> <span class="title class_">int</span> []&#123;tasks[i][<span class="number">0</span>],tasks[i][<span class="number">1</span>],i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(list,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt;queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>]!=b[<span class="number">1</span>])<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>]-b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> []res=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>, idx = <span class="number">0</span>; idx &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; list[j][<span class="number">0</span>] &lt;= time) queue.add(list[j++]);</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">                time = list[j][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">                res[idx++] = cur[<span class="number">2</span>];</span><br><span class="line">                time += cur[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-pass-ratio/">1792. 最大平均通过率</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240618001223909.png" alt="image-20240618001223909" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxAverageRatio</span><span class="params">(<span class="type">int</span>[][] classes, <span class="type">int</span> extraStudents)</span> &#123;</span><br><span class="line"> PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">val1</span> <span class="operator">=</span> (<span class="type">long</span>) (b[<span class="number">1</span>] + <span class="number">1</span>) * b[<span class="number">1</span>] * (a[<span class="number">1</span>] - a[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">long</span> <span class="variable">val2</span> <span class="operator">=</span> (<span class="type">long</span>) (a[<span class="number">1</span>] + <span class="number">1</span>) * a[<span class="number">1</span>] * (b[<span class="number">1</span>] - b[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (val1 == val2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val1 &lt; val2 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] c : classes) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;c[<span class="number">0</span>], c[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; extraStudents; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> arr[<span class="number">0</span>], total = arr[<span class="number">1</span>];</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;pass + <span class="number">1</span>, total + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classes.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pass</span> <span class="operator">=</span> arr[<span class="number">0</span>], total = arr[<span class="number">1</span>];</span><br><span class="line">            res += <span class="number">1.0</span> * pass / total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res / classes.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/meeting-rooms-iii/">2402. 会议室 III</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mostBooked</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings)</span> &#123;</span><br><span class="line">       <span class="type">var</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">       <span class="type">var</span> <span class="variable">idle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) idle.offer(i);</span><br><span class="line">       <span class="type">var</span> <span class="variable">using</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Pair&lt;Long, Integer&gt;&gt;((a, b) -&gt; !Objects.equals(a.getKey(), b.getKey()) ? Long.compare(a.getKey(), b.getKey()) : Integer.compare(a.getValue(), b.getValue()));</span><br><span class="line">       Arrays.sort(meetings, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> m : meetings) &#123;</span><br><span class="line">           <span class="type">long</span> <span class="variable">st</span> <span class="operator">=</span> m[<span class="number">0</span>], end = m[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">while</span> (!using.isEmpty() &amp;&amp; using.peek().getKey() &lt;= st) &#123;</span><br><span class="line">               idle.offer(using.poll().getValue()); <span class="comment">// 维护在 st 时刻空闲的会议室</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> id;</span><br><span class="line">           <span class="keyword">if</span> (idle.isEmpty()) &#123;</span><br><span class="line">               <span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> using.poll(); <span class="comment">// 没有可用的会议室，那么弹出一个最早结束的会议室（若有多个同时结束的，会弹出下标最小的）</span></span><br><span class="line">               end += p.getKey() - st; <span class="comment">// 更新当前会议的结束时间</span></span><br><span class="line">               id = p.getValue();</span><br><span class="line">           &#125; <span class="keyword">else</span> id = idle.poll();</span><br><span class="line">           ++cnt[id];</span><br><span class="line">           using.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(end, id)); <span class="comment">// 使用一个会议室</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">var</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (cnt[i] &gt; cnt[ans]) ans = i;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/">2940. 找到 Alice 和 Bob 可以相遇的建筑</a></p>
<p>这题关键在于记录下无法跳到的的末尾的位置，然后从这个末尾位置开始使用优先队列从小到排列与每个为的高度值对比求出可以一起跳到的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] leftmostBuildingQueries(<span class="type">int</span>[] heights, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">       Arrays.fill(ans, -<span class="number">1</span>);</span><br><span class="line">       List&lt;<span class="type">int</span>[]&gt;[] left = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[heights.length];</span><br><span class="line">       Arrays.setAll(left, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">qi</span> <span class="operator">=</span> <span class="number">0</span>; qi &lt; queries.length; qi++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queries[qi][<span class="number">0</span>], j = queries[qi][<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">               i = j;</span><br><span class="line">               j = temp; <span class="comment">// 保证 i &lt;= j</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (i == j || heights[i] &lt; heights[j]) &#123;</span><br><span class="line">               ans[qi] = j; <span class="comment">// i 直接跳到 j</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               left[j].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;heights[i], qi&#125;); <span class="comment">// 离线</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123; <span class="comment">// 从小到大枚举下标 i</span></span><br><span class="line">           <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">0</span>] &lt; heights[i]) &#123;</span><br><span class="line">               ans[pq.poll()[<span class="number">1</span>]] = i; <span class="comment">// 可以跳到 i（此时 i 是最小的）</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span>[] p : left[i]) &#123;</span><br><span class="line">               pq.offer(p); <span class="comment">// 后面再回答</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="§5-3-重排元素"><a href="#§5-3-重排元素" class="headerlink" title="§5.3 重排元素"></a>§5.3 重排元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-happy-string/">1405. 最长快乐字符串</a></p>
<p>此类题都是贪心和堆排序结合用堆排序满足贪心优先的想法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestDiverseString</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">       PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y)-&gt;y[<span class="number">1</span>]-x[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">if</span> (a &gt; <span class="number">0</span>) q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, a&#125;);</span><br><span class="line">       <span class="keyword">if</span> (b &gt; <span class="number">0</span>) q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, b&#125;);</span><br><span class="line">       <span class="keyword">if</span> (c &gt; <span class="number">0</span>) q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, c&#125;);</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">           <span class="type">int</span>[] cur = q.poll();</span><br><span class="line">           <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">           <span class="keyword">if</span> (n &gt;= <span class="number">2</span> &amp;&amp; sb.charAt(n - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span> == cur[<span class="number">0</span>] &amp;&amp; sb.charAt(n - <span class="number">2</span>) - <span class="string">&#x27;a&#x27;</span> == cur[<span class="number">0</span>]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">               <span class="type">int</span>[] next = q.poll();</span><br><span class="line">               sb.append((<span class="type">char</span>)(next[<span class="number">0</span>] + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">               <span class="keyword">if</span> (--next[<span class="number">1</span>] != <span class="number">0</span>) q.add(next);</span><br><span class="line">               q.add(cur);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append((<span class="type">char</span>)(cur[<span class="number">0</span>] + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">               <span class="keyword">if</span> (--cur[<span class="number">1</span>] != <span class="number">0</span>) q.add(cur);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="§5-4-第-K-小-x2F-大"><a href="#§5-4-第-K-小-x2F-大" class="headerlink" title="§5.4 第 K 小&#x2F;大"></a>§5.4 第 K 小&#x2F;大</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        PriorityQueue &lt;Long&gt;priorityQueue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt;set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1L</span>);</span><br><span class="line">        priorityQueue.add(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">long</span> temp=priorityQueue.poll();</span><br><span class="line">            <span class="keyword">if</span>(i==n)<span class="keyword">return</span> (<span class="type">int</span>)temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num:nums )&#123;</span><br><span class="line">                <span class="type">long</span> x=num*temp;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(x))&#123;</span><br><span class="line">                    set.add(x);</span><br><span class="line">                    priorityQueue.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">2386. 找出数组的第 K 大和</a></p>
<p><img src="/2023/10/23/Discussion-of-Leecode-question/2386.png" alt="image-20240308210525630"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">kSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                total += nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="type">long</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">long</span>[]&gt;((a, b) -&gt; Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;nums[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="type">long</span>[] arr = pq.poll();</span><br><span class="line">            <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) arr[<span class="number">1</span>];</span><br><span class="line">            ret = t;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;t + nums[i + <span class="number">1</span>], i + <span class="number">1</span>&#125;);</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;t - nums[i] + nums[i + <span class="number">1</span>], i + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total - ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="§5-5-反悔堆"><a href="#§5-5-反悔堆" class="headerlink" title="§5.5 反悔堆"></a>§5.5 反悔堆</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a></p>
<p>1.初始化血量 hp&#x3D;1。<br>2.从左到右遍历数组，把小于 0 的数丢到一个小根堆中。<br>3.遍历的同时，把 nums[i] 加到 hp 中。如果 hp&lt;1，那么弹出堆顶，hp 减去堆顶，相当于把之前扣掉的血重新加回来。同时把调整次数增加一。注意如果 hp&lt;1，那么必然是由当前这个小于 0 的 nums[i] 导致的，这一保证了此时堆不为空，二保证了 hp 减去堆顶后必然可以恢复成正数，因为堆顶不会比 nums[i] 还大。<br>4返回调整次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">magicTower</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt;queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> back=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;<span class="number">0</span>)queue.offer(num);</span><br><span class="line">            cur+=num;</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="type">int</span> n=queue.poll();</span><br><span class="line">                cur-=n;</span><br><span class="line">                back+=n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur+=back;</span><br><span class="line">        <span class="keyword">return</span> cur&gt;<span class="number">0</span>?res:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-iii/">630. 课程表 III</a></p>
<p>看上去，找不到一个合适的贪心策略。别放弃！顺着这个思路，如果我们可以「反悔」呢？</p>
<p>按照 lastDay 从小到大排序，然后遍历 courses。比如先上完 duration&#x3D;7 的课和 duration&#x3D;10 的课，后面遍历到了 duration&#x3D;4 的课，但受到 lastDay 的限制，无法上 duration&#x3D;4 的课。此时，我们可以「撤销」前面 duration 最长的课，也就是 duration&#x3D;10 的课，这样就可以上 duration&#x3D;4 的课了！虽然能上完的课程数目没有变化，但是由于我们多出了 10−4&#x3D;6 天时间，在后续的遍历中，更有机会上完更多的课程。</p>
<p>在上面的讨论中，我们需要维护一个数据结构，来帮助我们快速找到 duration 最长的课程。这可以用最大堆解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scheduleCourse</span><span class="params">(<span class="type">int</span>[][] courses)</span> &#123;</span><br><span class="line">       Arrays.sort(courses, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]); <span class="comment">// 按照 lastDay 从小到大排序</span></span><br><span class="line">       PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a); <span class="comment">// 最大堆</span></span><br><span class="line">       <span class="type">int</span> day=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> []course:courses)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">duration</span> <span class="operator">=</span> course[<span class="number">0</span>], lastDay = course[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(day+duration&lt;=lastDay)&#123;</span><br><span class="line">               day+=duration;</span><br><span class="line">               pq.offer(duration);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(!pq.isEmpty()&amp;&amp;duration&lt;pq.peek())&#123;</span><br><span class="line">               day-=pq.poll()-duration;</span><br><span class="line">               pq.offer(duration);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pq.size();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/earliest-second-to-mark-indices-ii/">3049. 标记所有下标的最早秒数 II</a></p>
<p>周赛题参见周赛</p>
<h3 id="§5-6-懒删除堆"><a href="#§5-6-懒删除堆" class="headerlink" title="§5.6 懒删除堆"></a>§5.6 懒删除堆</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-a-number-container-system/">2349. 设计数字容器系统</a></p>
<p>用最小堆堆存储改数字曾经存在于那个数据组中，然后再判断当前数据组是否存储这个数字如果存储返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberContainers</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt;map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,PriorityQueue&lt;Integer&gt;&gt;ms=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumberContainers</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        map.put(index,number);</span><br><span class="line">        ms.computeIfAbsent(number, k -&gt; <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;()).offer(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> q=ms.get(number); </span><br><span class="line">        <span class="keyword">if</span>(q==<span class="literal">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()&amp;&amp;map.get(q.peek())!=number)q.poll();</span><br><span class="line">        <span class="keyword">return</span> q.isEmpty()?-<span class="number">1</span>:q.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="§5-7-对顶堆"><a href="#§5-7-对顶堆" class="headerlink" title="§5.7 对顶堆"></a>§5.7 对顶堆</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></p>
<img src="/2023/10/23/Discussion-of-Leecode-question/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240710104545701.png" alt="image-20240710104545701" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt;min=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt;max=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        min = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (b - a));</span><br><span class="line">        max = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (a - b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty()||num&lt;=min.peek())&#123;</span><br><span class="line">            min.offer(num);</span><br><span class="line">            <span class="keyword">if</span>(max.size()+<span class="number">1</span>&lt;min.size())&#123;</span><br><span class="line">                max.offer(min.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max.offer(num);</span><br><span class="line">            <span class="keyword">if</span>(min.size()&lt;max.size())&#123;</span><br><span class="line">                min.offer(max.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(max.size()&lt;min.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> min.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max.peek()+min.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/">2102. 序列顺序查询</a></p>
<ol start="295">
<li>数据流的中位数的变种题<br>小根堆的最小值 &gt;&#x3D; 大根堆的最大值<br>295题求中间的一个或两个数，保证两个堆的大小差距不超过1即可<br>本题求第i个数(i等于get()的次数)，保证小根堆的大小等于i即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SORTracker</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = Comparator.comparing(scores::get)</span><br><span class="line">            .thenComparing(Comparator.comparing(names::get).reversed());</span><br><span class="line">    Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator);</span><br><span class="line">    Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator.reversed());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//使用 Lambda 表达式改写 Comparator</span></span><br><span class="line"><span class="comment">Comparator&lt;Integer&gt; comparator = (i1, i2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">    int scoreComparison = scores.get(i1).compareTo(scores.get(i2));</span></span><br><span class="line"><span class="comment">    if (scoreComparison != 0) &#123;</span></span><br><span class="line"><span class="comment">        return scoreComparison;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // If scores are the same, compare names in reversed order</span></span><br><span class="line"><span class="comment">    return names.get(i2).compareTo(names.get(i1));</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//重写 compare 方法</span></span><br><span class="line"><span class="comment">Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public int compare(Integer i1, Integer i2) &#123;</span></span><br><span class="line"><span class="comment">        int scoreComparison = scores.get(i1).compareTo(scores.get(i2));</span></span><br><span class="line"><span class="comment">        if (scoreComparison != 0) &#123;</span></span><br><span class="line"><span class="comment">            return scoreComparison;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">       // If scores are the same, compare names in reversed order</span></span><br><span class="line"><span class="comment">        return names.get(i2).compareTo(names.get(i1));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator);</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator.reversed());    Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer i1, Integer i2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreComparison</span> <span class="operator">=</span> scores.get(i1).compareTo(scores.get(i2));</span><br><span class="line">        <span class="keyword">if</span> (scoreComparison != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scoreComparison;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If scores are the same, compare names in reversed order</span></span><br><span class="line">        <span class="keyword">return</span> names.get(i2).compareTo(names.get(i1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator);</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(comparator.reversed());</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SORTracker</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        names.add(name);</span><br><span class="line">        scores.add(score);</span><br><span class="line">        minHeap.offer(names.size() - <span class="number">1</span>);</span><br><span class="line">        maxHeap.offer(minHeap.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        minHeap.offer(maxHeap.poll());</span><br><span class="line">        <span class="keyword">return</span> names.get(minHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、字典树（trie）"><a href="#六、字典树（trie）" class="headerlink" title="六、字典树（trie）"></a>六、字典树（trie）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                dfs(board, trie, i, j, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, Trie now, <span class="type">int</span> i1, <span class="type">int</span> j1, Set&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!now.children.containsKey(board[i1][j1])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> board[i1][j1];</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">nxt</span> <span class="operator">=</span> now.children.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(nxt.word)) &#123;</span><br><span class="line">            ans.add(nxt.word);</span><br><span class="line">            nxt.word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nxt.children.isEmpty()) &#123;</span><br><span class="line">            board[i1][j1] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 + dir[<span class="number">0</span>], j2 = j1 + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span> &amp;&amp; i2 &lt; board.length &amp;&amp; j2 &gt;= <span class="number">0</span> &amp;&amp; j2 &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    dfs(board, nxt, i2, j2, ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i1][j1] = ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nxt.children.isEmpty()) &#123;</span><br><span class="line">            now.children.remove(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    String word;</span><br><span class="line">    Map&lt;Character, Trie&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Trie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line">                cur.children.put(c, <span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.word = word;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii/">3045. 统计前后缀下标对 II</a></p>
<p>将字符的前n位和倒数n位一起拼成一个组，这个就可以将该组作为一个前缀树节点，然后依次判断该组出现的次数累加即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    Map&lt;Integer,Trie&gt;son=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countPrefixSuffixPairs</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">        Trie t=<span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s :words)&#123;</span><br><span class="line">            <span class="type">char</span> c[]=s.toCharArray();</span><br><span class="line">            <span class="type">int</span> n=c.length;</span><br><span class="line">            Trie cur=t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> pos=(c[i]-<span class="string">&#x27;a&#x27;</span>)&lt;&lt;<span class="number">5</span>|(c[n-<span class="number">1</span>-i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                cur=cur.son.computeIfAbsent(pos, k-&gt;<span class="keyword">new</span> <span class="title class_">Trie</span>());</span><br><span class="line">                res+=cur.cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="§6-3-字典树优化-DP"><a href="#§6-3-字典树优化-DP" class="headerlink" title="§6.3 字典树优化 DP"></a>§6.3 字典树优化 DP</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break-ii/">140. 单词拆分 II</a></p>
<p><img src="https://pic.leetcode-cn.com/1604155779-zGMFLS-image.png" alt="image.png"></p>
<p>此题先将类似于单词拆分1 记录这个字符串能否被拆分成对应的单词set，然后再从后往前回溯便利每个dp[i]&#x3D;&#x3D;true 的单词求得集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt;set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">int</span> n=s.length();</span><br><span class="line">    <span class="type">boolean</span> dp[]=<span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(s.substring(j,i))&amp;&amp;dp[j])&#123;</span><br><span class="line">                dp[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (dp[n]) &#123;</span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(s, n, set, dp, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s ,<span class="type">int</span> n,Set&lt;String&gt;set,<span class="type">boolean</span> dp[],</span></span><br><span class="line"><span class="params">Deque&lt;String&gt;path,List&lt;String&gt; res)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(String.join(<span class="string">&quot; &quot;</span>, path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            String word=s.substring(j,n);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(word)&amp;&amp;dp[j])&#123;</span><br><span class="line">                path.addFirst(word);</span><br><span class="line">                dfs(s, j, set, dp, path, res);</span><br><span class="line">                path.removeFirst(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七、并查集"><a href="#七、并查集" class="headerlink" title="七、并查集"></a>七、并查集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sentence-similarity-ii/">737. 句子相似性 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilarTwo</span><span class="params">(String[] sentence1, String[] sentence2, List&lt;List&lt;String&gt;&gt; similarPairs)</span> &#123;   </span><br><span class="line">        <span class="keyword">if</span> (sentence1.length != sentence2.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;String, Integer&gt; index = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        sim s=<span class="keyword">new</span> <span class="title class_">sim</span>(<span class="number">2</span>*similarPairs.size());</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt;pair:similarPairs)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String p:pair)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!index.containsKey(p))&#123;</span><br><span class="line">                    index.put(p,count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sim.union(index.get(pair.get(<span class="number">0</span>)),index.get(pair.get(<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sentence1.length;i++)&#123;</span><br><span class="line">            String s1=sentence1[i],s2=sentence2[i];</span><br><span class="line">            <span class="keyword">if</span>(s1.equals(s2))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!index.containsKey(s1)||!index.containsKey(s2)</span><br><span class="line">            ||sim.find(index.get(s1))!=sim.find(index.get(s2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sim</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> parent [];</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sim</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        parent=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x]!=x)parent[x]=find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        parent[find(x)]=find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/couples-holding-hands/">765. 情侣牵手</a></p>
<p>首先，我们总是以「情侣对」为单位进行设想：</p>
<p>当有两对情侣相互坐错了位置，ta们两对之间形成了一个环。需要进行一次交换，使得每队情侣独立（相互牵手）</p>
<p>如果三对情侣相互坐错了位置，ta们三对之间形成了一个环，需要进行两次交换，使得每队情侣独立（相互牵手）</p>
<p>如果四对情侣相互坐错了位置，ta们四对之间形成了一个环，需要进行三次交换，使得每队情侣独立（相互牵手）</p>
<p>也就是说，如果我们有 k 对情侣形成了错误环，需要交换 k - 1 次才能让情侣牵手。</p>
<p>于是问题转化成 n &#x2F; 2 对情侣中，有多少个这样的环。</p>
<p>可以直接使用「并查集」来做。</p>
<p>由于 0和1配对、2和3配对 … 因此互为情侣的两个编号除以 2 对应同一个数字，可直接作为它们的「情侣组」编号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=row.length;</span><br><span class="line">        <span class="type">int</span> t=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> f[]=<span class="keyword">new</span> <span class="title class_">int</span>[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            f[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x=row[i]/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> y=row[i+<span class="number">1</span>]/<span class="number">2</span>;</span><br><span class="line">            add(f,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> getf(f, i);</span><br><span class="line">            map.put(fx, map.getOrDefault(fx, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()) &#123;</span><br><span class="line">            res+=entry.getValue()-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getf</span><span class="params">(<span class="type">int</span>[] f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        f[x]=getf(f,f[x]);</span><br><span class="line">        <span class="keyword">return</span> f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fx=getf(f,x);</span><br><span class="line">        <span class="type">int</span> fy=getf(f,y);</span><br><span class="line">        f[fx]=fy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line">    <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">70</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=row.length, m=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            p[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            union(row[i]/<span class="number">2</span>, row[i+<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=find(i))res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[x]!=x)p[x]=find(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        p[find(x)]=find(y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/greatest-common-divisor-traversal/">2709. 最大公约数遍历</a></p>
<p>待定</p>
<h3 id="§7-3-公因数并查集"><a href="#§7-3-公因数并查集" class="headerlink" title="§7.3 公因数并查集"></a>§7.3 公因数并查集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/greatest-common-divisor-traversal/">2709. 最大公约数遍历</a></p>
<p>将每个数与自己的公因数相连，再遍历每个数，如果不相同则无法连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canTraverseAllPairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maxNum = Math.max(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(maxNum + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                    uf.union(num, i);</span><br><span class="line">                    uf.union(num, num / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currRoot</span> <span class="operator">=</span> uf.find(num);</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="number">0</span>) &#123;</span><br><span class="line">                root = currRoot;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currRoot != root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootx] &lt; rank[rooty]) &#123;</span><br><span class="line">                parent[rootx] = rooty;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rooty] = rootx;</span><br><span class="line">                rank[rootx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="§7-4-数组上的并查集"><a href="#§7-4-数组上的并查集" class="headerlink" title="§7.4 数组上的并查集"></a>§7.4 数组上的并查集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/avoid-flood-in-the-city/">1488. 避免洪水泛滥</a></p>
<h2 id="从集合论到位运算，常见位运算技巧分类总结"><a href="#从集合论到位运算，常见位运算技巧分类总结" class="headerlink" title="从集合论到位运算，常见位运算技巧分类总结"></a>从集合论到位运算，常见位运算技巧分类总结</h2><p><img src="/2023/10/23/Discussion-of-Leecode-question/set.png" alt="image-20240131223108107"></p>
<p><img src="/2023/10/23/Discussion-of-Leecode-question/set2.png" alt="image-20240131223636659"></p>
<p>三、遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((s &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// i 在 s 中</span></span><br><span class="line">        <span class="comment">// 处理 i 的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、枚举集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">    <span class="comment">// 处理 s 的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> s; sub &gt; <span class="number">0</span>; sub = (sub - <span class="number">1</span>) &amp; s) &#123;</span><br><span class="line">    <span class="comment">// 处理 sub 的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leecode/" rel="tag"># -leecode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/19/Spring%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/25/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU"><span class="nav-number">1.</span> <span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kruskal"><span class="nav-number">2.</span> <span class="nav-text">Kruskal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dijkstra"><span class="nav-number">3.</span> <span class="nav-text">Dijkstra</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1976-%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">1976. 到达目的地的方案数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd"><span class="nav-number">4.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BellmanFord"><span class="nav-number">5.</span> <span class="nav-text">BellmanFord</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dp%E9%A2%98%E7%9B%AE"><span class="nav-number">6.</span> <span class="nav-text">dp题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%85%A5%E9%97%A8-DP"><span class="nav-number">6.1.</span> <span class="nav-text">一、入门 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BD%91%E6%A0%BC%E5%9B%BE-DP"><span class="nav-number">6.2.</span> <span class="nav-text">二、网格图 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2435-%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%AB-K-%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">6.3.</span> <span class="nav-text">2435. 矩阵中和能被 K 整除的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F"><span class="nav-number">6.4.</span> <span class="nav-text">174. 地下城游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#741-%E6%91%98%E6%A8%B1%E6%A1%83"><span class="nav-number">6.5.</span> <span class="nav-text">741. 摘樱桃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%83%8C%E5%8C%85"><span class="nav-number">6.6.</span> <span class="nav-text">三、背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">6.6.1.</span> <span class="nav-text">01背包理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">6.6.1.1.</span> <span class="nav-text">一维dp数组（滚动数组）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">6.6.2.</span> <span class="nav-text">完全背包理论基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">6.6.3.</span> <span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">6.6.4.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BB%8F%E5%85%B8%E7%BA%BF%E6%80%A7-DP"><span class="nav-number">6.7.</span> <span class="nav-text">四、经典线性 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A74-1-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89"><span class="nav-number">6.7.1.</span> <span class="nav-text">§4.1 最长公共子序列（LCS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A74-2-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89"><span class="nav-number">6.7.2.</span> <span class="nav-text">§4.2 最长递增子序列（LIS）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA-DP"><span class="nav-number">6.8.</span> <span class="nav-text">五、状态机 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%88%92%E5%88%86%E5%9E%8B-DP"><span class="nav-number">6.9.</span> <span class="nav-text">六、划分型 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A76-1-%E5%88%A4%E5%AE%9A%E8%83%BD%E5%90%A6%E5%88%92%E5%88%86"><span class="nav-number">6.9.1.</span> <span class="nav-text">§6.1 判定能否划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A76-2-%E8%AE%A1%E7%AE%97%E5%88%92%E5%88%86%E4%B8%AA%E6%95%B0"><span class="nav-number">6.9.2.</span> <span class="nav-text">§6.2 计算划分个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A76-3-%E7%BA%A6%E6%9D%9F%E5%88%92%E5%88%86%E4%B8%AA%E6%95%B0"><span class="nav-number">6.9.3.</span> <span class="nav-text">§6.3 约束划分个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A76-4-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4"><span class="nav-number">6.9.4.</span> <span class="nav-text">§6.4 不相交区间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E5%AE%83%E7%BA%BF%E6%80%A7-DP"><span class="nav-number">6.10.</span> <span class="nav-text">七、其它线性 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A77-1-%E4%B8%80%E7%BB%B4"><span class="nav-number">6.10.1.</span> <span class="nav-text">§7.1 一维</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A77-2-%E7%89%B9%E6%AE%8A%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">6.10.2.</span> <span class="nav-text">§7.2 特殊子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A77-3-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BC%98%E5%8C%96"><span class="nav-number">6.10.3.</span> <span class="nav-text">§7.3 矩阵快速幂优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%8C%BA%E9%97%B4-DP"><span class="nav-number">6.11.</span> <span class="nav-text">八、区间 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A78-1-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">6.11.1.</span> <span class="nav-text">§8.1 最长回文子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A78-2-%E5%85%B6%E5%AE%83%E5%8C%BA%E9%97%B4-DP"><span class="nav-number">6.11.2.</span> <span class="nav-text">§8.2 其它区间 DP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-DP%EF%BC%88%E7%8A%B6%E5%8E%8B-DP%EF%BC%89"><span class="nav-number">6.12.</span> <span class="nav-text">九、状态压缩 DP（状压 DP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A79-1-%E6%8E%92%E5%88%97%E5%9E%8B-%E2%91%A0-%E7%9B%B8%E9%82%BB%E6%97%A0%E5%85%B3"><span class="nav-number">6.12.1.</span> <span class="nav-text">§9.1 排列型 ① 相邻无关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A79-2-%E6%8E%92%E5%88%97%E5%9E%8B-%E2%91%A1-%E7%9B%B8%E9%82%BB%E7%9B%B8%E5%85%B3"><span class="nav-number">6.12.2.</span> <span class="nav-text">§9.2 排列型 ② 相邻相关</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A79-3-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88TSP%EF%BC%89"><span class="nav-number">6.12.3.</span> <span class="nav-text">§9.3 旅行商问题（TSP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A79-4-%E6%9E%9A%E4%B8%BE%E5%AD%90%E9%9B%86%E7%9A%84%E5%AD%90%E9%9B%86"><span class="nav-number">6.12.4.</span> <span class="nav-text">§9.4 枚举子集的子集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A79-5-%E5%85%B6%E5%AE%83%E7%8A%B6%E5%8E%8B-D"><span class="nav-number">6.12.5.</span> <span class="nav-text">§9.5 其它状压 D</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E6%95%B0%E4%BD%8D-DP"><span class="nav-number">6.13.</span> <span class="nav-text">十、数位 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96-DP"><span class="nav-number">6.14.</span> <span class="nav-text">十一、数据结构优化 DP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%A0%91%E5%BD%A2-DP"><span class="nav-number">6.15.</span> <span class="nav-text">十二、树形 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A712-1-%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">6.15.1.</span> <span class="nav-text">§12.1 树的直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A712-2-%E6%A0%91%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="nav-number">6.15.2.</span> <span class="nav-text">§12.2 树上最大独立集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A712-3-%E6%A0%91%E4%B8%8A%E6%9C%80%E5%B0%8F%E6%94%AF%E9%85%8D%E9%9B%86"><span class="nav-number">6.15.3.</span> <span class="nav-text">§12.3 树上最小支配集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%C2%A712-4-%E6%8D%A2%E6%A0%B9-DP"><span class="nav-number">6.15.4.</span> <span class="nav-text">§12.4 换根 DP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">7.</span> <span class="nav-text">图的建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-number">8.</span> <span class="nav-text">线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">8.1.</span> <span class="nav-text">线段树的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2407-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-II-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="nav-number">8.1.1.</span> <span class="nav-text">2407. 最长递增子序列 II - 力扣（LeetCode）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="nav-number">9.</span> <span class="nav-text">树状数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">五、堆（优先队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A75-3-%E9%87%8D%E6%8E%92%E5%85%83%E7%B4%A0"><span class="nav-number">10.1.</span> <span class="nav-text">§5.3 重排元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A75-4-%E7%AC%AC-K-%E5%B0%8F-x2F-%E5%A4%A7"><span class="nav-number">10.2.</span> <span class="nav-text">§5.4 第 K 小&#x2F;大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A75-5-%E5%8F%8D%E6%82%94%E5%A0%86"><span class="nav-number">10.3.</span> <span class="nav-text">§5.5 反悔堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A75-6-%E6%87%92%E5%88%A0%E9%99%A4%E5%A0%86"><span class="nav-number">10.4.</span> <span class="nav-text">§5.6 懒删除堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A75-7-%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="nav-number">10.5.</span> <span class="nav-text">§5.7 对顶堆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88trie%EF%BC%89"><span class="nav-number">11.</span> <span class="nav-text">六、字典树（trie）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A76-3-%E5%AD%97%E5%85%B8%E6%A0%91%E4%BC%98%E5%8C%96-DP"><span class="nav-number">11.1.</span> <span class="nav-text">§6.3 字典树优化 DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">12.</span> <span class="nav-text">七、并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A77-3-%E5%85%AC%E5%9B%A0%E6%95%B0%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">12.1.</span> <span class="nav-text">§7.3 公因数并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%C2%A77-4-%E6%95%B0%E7%BB%84%E4%B8%8A%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">12.2.</span> <span class="nav-text">§7.4 数组上的并查集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%9B%86%E5%90%88%E8%AE%BA%E5%88%B0%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E5%B8%B8%E8%A7%81%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">从集合论到位运算，常见位运算技巧分类总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stigwang</p>
  <div class="site-description" itemprop="description">show me the code！！！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stigwang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
