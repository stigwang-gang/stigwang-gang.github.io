<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="算法题总结 数组1、如何处理循环数组使用2倍的数组长度来取%完成一次循环,可以查找到前半部分的数组 1234567for (int i&#x3D;1;i&lt;2*nums.length;i++)&amp;#123;           while(!st.isEmpty()&amp;&amp;nums[i]&gt;nums[st.peek()])&amp;#123;               result[st.pee">
<meta property="og:type" content="article">
<meta property="og:title" content="sum up of leecode">
<meta property="og:url" content="http://example.com/2023/09/19/leecode-sum-up/index.html">
<meta property="og:site_name" content="StigWang&#39;s code recording">
<meta property="og:description" content="算法题总结 数组1、如何处理循环数组使用2倍的数组长度来取%完成一次循环,可以查找到前半部分的数组 1234567for (int i&#x3D;1;i&lt;2*nums.length;i++)&amp;#123;           while(!st.isEmpty()&amp;&amp;nums[i]&gt;nums[st.peek()])&amp;#123;               result[st.pee">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/378/378_fig3.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240403163417829.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/1600878237-pBiBdf-Picture1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/9114fb790bb1b3411bdc02d6dcb52ec721b87768d7858be7373d23f8edd82d8a-image.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021051617101194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUzMTk2Ng==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210506221229133.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210506221249385.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021050622130485.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021050622131862.gif">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20230422164916915.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202105062211506.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210506220742403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUzMTk2Ng==,size_32,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202105161702205.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210516170800145.gif">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/2386.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/cc43daa8cbb755373ce4c5cd10c44066dc770a34a6d2913a52f8047cbf5e6e56-file_1559548337458">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/866b404c6b0b52fa02385e301ee907fc015742c3766c80c02e24ef3a8613e5ad-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1615105150-pfWiGq-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1615105168-ZQRZew-image.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/1002.%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif">
<meta property="og:image" content="https://pic.leetcode.cn/1698978713-ouzPib-lc421-c.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1662480137-TJiyfu-1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1662435980-lzhQam-1.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1638612131-tGESRo-ccw-01-09.005.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/2851.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/a6e7991ce6497ac56cb5fdd2fae18cedba5881d7c677fb7dd41442843c9c7771-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/dcbea3c3418c57db4a582003dafc476e91b9f48bdf511727cfa5335d392d8566-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/542754f4431d93141920185252aee31664a96dd17285b92dfe390e9e977bebb1-image.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/1599885247-mgYjRv-Picture2.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903-20230310123444151.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303-20230310122134167.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1614650837-SAIiWg-1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/77d1aa6a444743d3c8606ac951cd7fc38faf68a62064fd2639df517cd666a4d0-Picture1.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1639228731-hwXkOI-image.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png">
<meta property="og:image" content="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/514.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/1691(1).png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/1691(2).png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1662829933-UuachQ-51.svg">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/402/10.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20220811/2250031660229403W4grn725.svg">
<meta property="og:image" content="https://pic.leetcode-cn.com/c95f25c4df2dce2f872fdc076bc0c8168c3ad241b8bd18638da68112e013c908-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/52d1a28110784aee9b145cd725834a51a4e9e7e87e5ec5a2ba2c83f42c44dc79-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/0df9d3c5f9647b040b001c42c2e946975ddcc282f0c805d85e3addb126f7b695-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1609861645-DbxMDs-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1609862151-XZgKGY-image.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/1137.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20230430151444159.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1603612327-bOQxzq-Picture1.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/2575.png">
<meta property="og:image" content="http://example.com/2023/09/19/leecode-sum-up/Users/%E7%8E%8B%E5%88%9A/AppData/Roaming/Typora/typora-user-images/image-20240729084058459.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/63f5803e9452ccecf92fa64f54c887ed0e4e4c3434b9fb246bf2b410e4424555.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/5a91ec351bcbe8e631e7e3e44e062794d6e53af95f6a5c778de369365b9d994e.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png">
<meta property="og:image" content="https://pic.leetcode.cn/1689398667-omjvbD-lc834.png">
<meta property="article:published_time" content="2023-09-20T01:23:16.589Z">
<meta property="article:modified_time" content="2024-08-03T09:26:35.356Z">
<meta property="article:author" content="stigwang">
<meta property="article:tag" content="leecode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/solution-static/378/378_fig3.png">

<link rel="canonical" href="http://example.com/2023/09/19/leecode-sum-up/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>sum up of leecode | StigWang's code recording</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StigWang's code recording</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/19/leecode-sum-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stigwang">
      <meta itemprop="description" content="show me the code！！！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StigWang's code recording">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          sum up of leecode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-20 09:23:16" itemprop="dateCreated datePublished" datetime="2023-09-20T09:23:16+08:00">2023-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-08-03 17:26:35" itemprop="dateModified" datetime="2024-08-03T17:26:35+08:00">2024-08-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>算法题总结</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1、如何处理循环数组"><a href="#1、如何处理循环数组" class="headerlink" title="1、如何处理循环数组"></a>1、如何处理循环数组</h2><p>使用2倍的数组长度来取%完成一次循环,可以查找到前半部分的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!st.isEmpty()&amp;&amp;nums[i]&gt;nums[st.peek()])&#123;</span><br><span class="line">               result[st.peek()] = nums[i % nums.length];<span class="comment">//更新result</span></span><br><span class="line">               st.pop();<span class="comment">//弹出栈顶</span></span><br><span class="line">           &#125;</span><br><span class="line">           st.push(i);</span><br><span class="line">       &#125;nums[i]=nums[i % nums.length]; </span><br></pre></td></tr></table></figure>

<h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//二分寻找插入位置 第一种左闭右闭</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;[mid+<span class="number">1</span>,right]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;[left,mid-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line"><span class="comment">//第二种左闭右开</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;[mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid ;[left,mid)</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">return</span> left;<span class="comment">//right;都可以</span></span><br><span class="line">  <span class="comment">//第三种左开右开                        </span></span><br><span class="line"> <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>, right = nums.length; <span class="comment">// 开区间 (left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                left = mid; <span class="comment">//  (mid, right)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid; <span class="comment">//  (left, mid)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I-考察二分法"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I-考察二分法" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I 考察二分法"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I 考察二分法</h4><p>考察了对于二分查找后对数据左右边界判断的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[begin] == nums[end]) &#123;</span><br><span class="line">        <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[begin] &lt; target) &#123;</span><br><span class="line">        begin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] &gt; target) &#123;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-II-0～n-1中缺失的数字-思想依然是二分查找的方法"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字-思想依然是二分查找的方法" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字 思想依然是二分查找的方法"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字 思想依然是二分查找的方法</h4><p>考察如何对于low和high两个数值的修改判断出缺失数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]!=mid)high=mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//最后return</span></span><br><span class="line"><span class="keyword">return</span> low;</span><br></pre></td></tr></table></figure>

<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>思路是数量既然是1-n之中存在，但是却有n+1个笼子那可以只用二分查找缩小查找范围，如果小于mid数字多那就是小的那半重复，如果大于mid多就是大于部分重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">    <span class="type">int</span> half=(r-l)/<span class="number">2</span>+l;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=half)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;=half)&#123;</span><br><span class="line">        l=half+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        r=half-<span class="number">1</span>;</span><br><span class="line">        res=half;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h4><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h4><p>这两个题目的破题关键:</p>
<p>定理一：只有在顺序区间内才可以通过区间两端的数值判断target是否在其中。</p>
<p>定理二：判断顺序区间还是乱序区间，只需要对比 left 和 right 是否是顺序对即可，left &lt;&#x3D; right，顺序区间，否则乱序区间。</p>
<p>定理三：每次二分都会至少存在一个顺序区间。</p>
<p>通过不断的用Mid二分，根据定理二，将整个数组划分成顺序区间和乱序区间，然后利用定理一判断target是否在顺序区间，如果在顺序区间，下次循环就直接取顺序区间，如果不在，那么下次循环就取乱序区间。</p>
<p><font color="red"><strong>将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。 此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</strong> </font></p>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><p>假设我们要找第 <code>k</code> 小数，我们可以每次循环排除掉 <code>k/2</code> 个数，所以我们采用递归的思路，为了防止数组长度小于 k&#x2F;2，所以每次比较 min(k&#x2F;2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k&#x3D;1 或者其中一个数字长度是 0 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">    <span class="keyword">return</span> (getKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+ getKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right)) * <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= nums1.length) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];<span class="comment">//nums1为空数组</span></span><br><span class="line">        <span class="keyword">if</span>( j &gt;= nums2.length) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];<span class="comment">//nums2为空数组</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数值情况如何你寻找第k大的数都需要排除前k个数 所以无需理睬数组长度小的数，如果最后长度和小长度的数组一致了，那意味着到达新的k分解一样正常分解</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal1</span> <span class="operator">=</span> (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal2</span> <span class="operator">=</span> (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(midVal1 &lt; midVal2)&#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="378-有序矩阵中第-K-小的元素-力扣（LeetCode）"><a href="#378-有序矩阵中第-K-小的元素-力扣（LeetCode）" class="headerlink" title="378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode）"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/description/">378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode）</a></h4><p> 此题二分是因为本身矩阵是有序的，我们找值时总最小的最左值到最大的右下值进行二分查找，小于此值的都在上板部分，统计这部分个数，然后就可以返回结果，对于数组我们选用梯形遍历从左下角一直遍历到右上角</p>
<img src="https://assets.leetcode-cn.com/solution-static/378/378_fig3.png" alt="fig3" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (check(matrix, mid, k, n)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> mid, <span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">            num += i + <span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> lowerBound(nums, target); <span class="comment">// 选择其中一种写法即可</span></span><br><span class="line">        <span class="keyword">if</span> (start == nums.length || nums[start] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;; <span class="comment">// nums 中没有 target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 start 存在，那么 end 必定存在</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> lowerBound(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lowerBound 返回最小的满足 nums[i] &gt;= target 的 i</span></span><br><span class="line">    <span class="comment">// 如果数组为空，或者所有数都 &lt; target，则返回 nums.length</span></span><br><span class="line">    <span class="comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭区间写法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 区间不为空</span></span><br><span class="line">            <span class="comment">// 循环不变量：</span></span><br><span class="line">            <span class="comment">// nums[left-1] &lt; target</span></span><br><span class="line">            <span class="comment">// nums[right+1] &gt;= target</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 范围缩小到 [mid+1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 范围缩小到 [left, mid-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></p>
<p>不难发现，如果 在确保有解的情况下，我们可以根据当前的分割点 mid 与左右元素的大小关系来指导 l 或者 r 的移动。</p>
<p>假设当前分割点 mid 满足关系 num[mid]&gt;nums[mid+1] 的话，一个很简单的想法是 num[mid] 可能为峰值，而 nums[mid+1] 必然不为峰值，于是让 r&#x3D;mid，从左半部分继续找峰值。</p>
<p>估计不少同学靠这个思路 AC 了，只能说做法对了，分析没对。</p>
<p>上述做法正确的前提有两个：</p>
<p>对于任意数组而言，一定存在峰值（一定有解）；<br>二分不会错过峰值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、删除数组时使用双指针法"><a href="#3、删除数组时使用双指针法" class="headerlink" title="3、删除数组时使用双指针法"></a>3、删除数组时使用双指针法</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法"></p>
<p><strong>双指针在遇到不满足条件时一起增加但是在满足条件时快指针动这样可以将后面元素加上来</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fastIndex]) &#123;</span><br><span class="line">                nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>双指针还可以用于前后倒序排列</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] * nums[l] &gt; nums[r] * nums[r])&#123;</span><br><span class="line">                res[j--] = nums[l] * nums[l++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[j--] = nums[r] * nums[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h3><p><img src="/2023/09/19/leecode-sum-up/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240403163417829.png" alt="image-20240403163417829"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">p0</span> <span class="operator">=</span> <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">               nums[i] = nums[p1];</span><br><span class="line">               nums[p1] = temp;</span><br><span class="line">               ++p1;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">               nums[i] = nums[p0];</span><br><span class="line">               nums[p0] = temp;</span><br><span class="line">               <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                   temp = nums[i];</span><br><span class="line">                   nums[i] = nums[p1];</span><br><span class="line">                   nums[p1] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">               ++p0;</span><br><span class="line">               ++p1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// l 标记从前往后找到第一个出现降序的下标，nums[l] &gt; nums[l + 1]</span></span><br><span class="line">       <span class="keyword">while</span> (l + <span class="number">1</span> &lt; n &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) &#123;</span><br><span class="line">           l++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 若l == n - 1, 说明 nums 为升序序列</span></span><br><span class="line">       <span class="keyword">if</span> (l == n - <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - <span class="number">1</span>; <span class="comment">// r 标记从后往前找到第一个出现升序的下标，nums[r] &lt; nums[r - 1]</span></span><br><span class="line">       <span class="keyword">while</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[r] &gt;= nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 在子区间 [l, r] 中找到最小值 min 和最大值 max*/</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[l];</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[r];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r; i &lt;= r &amp;&amp; j &gt;= l; i++, j--) &#123;</span><br><span class="line">           min = min &lt; nums[i] ? min : nums[i];</span><br><span class="line">           max = max &gt; nums[j] ? max : nums[j];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 从 l 开始向前查找 min 在 nums 中的最终位置 l */</span></span><br><span class="line">       <span class="keyword">while</span> (l - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[l - <span class="number">1</span>] &gt; min) &#123;</span><br><span class="line">           l--;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 从 r 开始向后查找 max 在 nums 中的最终位置 r*/</span></span><br><span class="line">       <span class="keyword">while</span> (r + <span class="number">1</span> &lt; n &amp;&amp; nums[r + <span class="number">1</span>] &lt; max) &#123;</span><br><span class="line">           r++;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 确定无序子数组的最小值和最大值的最终位置后，[l, r] 中的元素就是原数组 nums 待排序的子数组*/</span></span><br><span class="line">       <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、滑动窗口"><a href="#5、滑动窗口" class="headerlink" title="5、滑动窗口"></a>5、滑动窗口</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = INT32_MAX;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">    <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">            result = result &lt; subLength ? result : subLength;</span><br><span class="line">            sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">    <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif" alt="fig1"></p>
<p><font color="red"><strong>注意需要统计次数时或者不求最大值时建议使用hashmap配合这样滑动窗口可以包含自身</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//76. 最小覆盖子串  https://leetcode.cn/problems/minimum-window-substring/description/</span></span><br><span class="line"><span class="comment">//这里面i就是r j就是l通过i右移先包含整个t字符然后再j右移删除无效字符 使用length 判断是否已经将t的字符全部匹配</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] sc = s.toCharArray();<span class="type">char</span>[] tc = t.toCharArray();</span><br><span class="line">    <span class="type">int</span> [] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : tc) hash[ch]--;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">        hash[sc[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(hash[sc[i]]&lt;=<span class="number">0</span>)length++;</span><br><span class="line">        <span class="keyword">while</span> (length == tc.length &amp;&amp; hash[sc[j]] &gt; <span class="number">0</span>) hash[sc[j++]]--;</span><br><span class="line">        <span class="keyword">if</span>(length==tc.length)</span><br><span class="line">            <span class="keyword">if</span>(res.equals(<span class="string">&quot;&quot;</span>)||res.length()&gt;i-j+<span class="number">1</span>)</span><br><span class="line">                res=s.substring(j,i+<span class="number">1</span>);`</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4><h4 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h4><p>这两题拥有相同的思路将窗口开到指定大小在窗口大小内寻找是否符合要求，通过右指针到达具体窗口大小,左指针移动来整个平移滑动窗口,比较在规定窗口内的值是否符合答案.</p>
<p>![滑动窗口求解最长连续子串长度](<a target="_blank" rel="noopener" href="https://pic.leetcode-cn.com/578fc15b7b426eb61dcf1fd73bb87f1511d8733c474797dbb9188b706a219cc5.jpg">https://pic.leetcode-cn.com/578fc15b7b426eb61dcf1fd73bb87f1511d8733c474797dbb9188b706a219cc5.jpg</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">424</span></span><br><span class="line"><span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; historyCharMax + k) &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">567</span></span><br><span class="line"><span class="keyword">if</span>(right-left+<span class="number">1</span>==length1)<span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><img src="https://pic.leetcode-cn.com/1600878237-pBiBdf-Picture1.png" alt="Picture1.png" style="zoom: 50%;">

<p>只要元素a&gt;元素b而且元素a还在元素b的右侧，那么当滑动窗口移动时，元素b在不在队列里最大值都是元素a所以就可以在add时去除b元素，在弹出时判断该元素是否存在再弹出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">Deque&lt;Integer&gt;queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k,j=<span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">    res[j++]=queue.peek();</span><br><span class="line">    <span class="keyword">if</span>(nums[i-k]==queue.peek())</span><br><span class="line">        queue.poll();</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;queue.getLast()&lt;nums[i])</span><br><span class="line">    &#123;</span><br><span class="line">        queue.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    queue.offer(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h4 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><p>我们每次移动一个单词的长度，也就是 3 个字符，这样所有的移动被分成了三类。总共需要移动对比的次数就是一个word的长度因为我们滑动窗口是以每个word长度进行的根据鸽笼原理大于word长度x开始的都是前面word长度以内开始的子情况，之后就是三种情况完全相同count &#x3D;&#x3D; word_num 添加坐标，不同则清空left移动到不同的之后，对应word数量不同也清空left移动一位</p>
<p><img src="https://pic.leetcode-cn.com/9114fb790bb1b3411bdc02d6dcb52ec721b87768d7858be7373d23f8edd82d8a-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSubstring</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span> || words == <span class="literal">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">one_word</span> <span class="operator">=</span> words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">word_num</span> <span class="operator">=</span> words.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">all_len</span> <span class="operator">=</span> one_word * word_num;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; one_word; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = i, count = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;String, Integer&gt; tmp_map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right + one_word &lt;= s.length()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> s.substring(right, right + one_word);</span><br><span class="line">            right += one_word;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(w)) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                left = right;</span><br><span class="line">                tmp_map.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp_map.put(w, tmp_map.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">while</span> (tmp_map.getOrDefault(w, <span class="number">0</span>) &gt; map.getOrDefault(w, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">t_w</span> <span class="operator">=</span> s.substring(left, left + one_word);</span><br><span class="line">                    count--;</span><br><span class="line">                    tmp_map.put(t_w, tmp_map.getOrDefault(t_w, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                    left += one_word;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == word_num) res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1、基本排序介绍"><a href="#1、基本排序介绍" class="headerlink" title="1、基本排序介绍"></a>1、基本排序介绍</h2><p><img src="https://img-blog.csdnimg.cn/2021051617101194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUzMTk2Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-冒泡排序-Bubble-Sort"><a href="#1-冒泡排序-Bubble-Sort" class="headerlink" title="1.冒泡排序(Bubble Sort)"></a>1.<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F&spm=1001.2101.3001.7020">冒泡排序</a>(Bubble Sort)</h3><p><img src="https://img-blog.csdnimg.cn/20210506221229133.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort1_01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j]&gt;a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="type">int</span> temp=a[j];</span><br><span class="line">					a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">					a[j+<span class="number">1</span>]=temp;</span><br><span class="line">					flag=<span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(a));<span class="comment">// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;一共比较了：&quot;</span>+count+<span class="string">&quot;次&quot;</span>);<span class="comment">//一共比较了：95次</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序-Select-Sort"><a href="#2-选择排序-Select-Sort" class="headerlink" title="2.选择排序(Select Sort)"></a>2.选择排序(Select Sort)</h3><p><img src="https://img-blog.csdnimg.cn/20210506221249385.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//选择排序:先定义一个记录最小元素的下标，然后循环一次后面的，找到最小的元素，最后将他放到前面排序好的序列。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort_02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> index=i;<span class="comment">//标记第一个为待比较的数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; a.length; j++) &#123; <span class="comment">//然后从后面遍历与第一个数比较</span></span><br><span class="line">				<span class="keyword">if</span> (a[j]&lt;a[index]) &#123;  <span class="comment">//如果小,就交换最小值</span></span><br><span class="line">					index=j;<span class="comment">//保存最小元素的下标</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//找到最小值后，将最小的值放到第一的位置，进行下一遍循环</span></span><br><span class="line">			<span class="type">int</span> temp=a[index];</span><br><span class="line">			a[index]=a[i];</span><br><span class="line">			a[i]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(a));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序-Insert-Sort"><a href="#3-插入排序-Insert-Sort" class="headerlink" title="3.插入排序(Insert Sort)"></a>3.插入排序(Insert Sort)</h3><p><img src="https://img-blog.csdnimg.cn/2021050622130485.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//插入排序:定义一个待插入的数，再定义一个待插入数的前一个数的下标，然后拿待插入数与前面的数组一一比较，最后交换。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort_03</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;  <span class="comment">//长度不减1，是因为要留多一个位置方便插入数</span></span><br><span class="line">			<span class="comment">//定义待插入的数</span></span><br><span class="line">			<span class="type">int</span> insertValue=a[i];</span><br><span class="line">			<span class="comment">//找到待插入数的前一个数的下标</span></span><br><span class="line">			<span class="type">int</span> insertIndex=i-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (insertIndex&gt;=<span class="number">0</span> &amp;&amp; insertValue &lt;a[insertIndex]) &#123;<span class="comment">//拿a[i]与a[i-1]的前面数组比较</span></span><br><span class="line">				a[insertIndex+<span class="number">1</span>]=a[insertIndex];</span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			a[insertIndex+<span class="number">1</span>]=insertValue;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(a));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-希尔排序-Shell-Sort"><a href="#4-希尔排序-Shell-Sort" class="headerlink" title="4.希尔排序(Shell Sort)"></a>4.希尔排序(Shell Sort)</h3><p><img src="https://img-blog.csdnimg.cn/2021050622131862.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//希尔排序：插入排序的升级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort_04</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		<span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//比较次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> gap=a.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">//将整个数组分为若干个子数组</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; a.length; i++) &#123;</span><br><span class="line">				<span class="comment">//遍历各组的元素</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j&gt;=<span class="number">0</span>; j=j-gap) &#123;</span><br><span class="line">					<span class="comment">//交换元素</span></span><br><span class="line">					<span class="keyword">if</span> (a[j]&gt;a[j+gap]) &#123;</span><br><span class="line">						<span class="type">int</span> temp=a[j];</span><br><span class="line">						a[j]=a[j+gap];</span><br><span class="line">						a[j+gap]=temp;</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(count);<span class="comment">//16</span></span><br><span class="line">		System.out.println(Arrays.toString(a));<span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-快速排序-Quick-Sort"><a href="#5-快速排序-Quick-Sort" class="headerlink" title="5.快速排序(Quick Sort)"></a>5.快速排序(Quick Sort)</h3><p><img src="/2023/09/19/leecode-sum-up/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20230422164916915.png" alt="image-20230422164916915"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//快速排序：冒泡排序的升华版</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort_05</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//int a[]=&#123;50,1,12,2&#125;;</span></span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		quicksort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">		<span class="type">int</span> i,j;</span><br><span class="line">		<span class="keyword">if</span> (low&gt;high) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i=low;</span><br><span class="line">		j=high;</span><br><span class="line">		<span class="type">int</span> temp=a[low];<span class="comment">//基准位,low=length时，会报异常，java.lang.ArrayIndexOutOfBoundsException: 4 ，所以必须在if判断后面,就跳出方法。</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">			<span class="comment">//先从右边开始往左递减，找到比temp小的值才停止</span></span><br><span class="line">			<span class="keyword">while</span> ( temp&lt;=a[j] &amp;&amp; i&lt;j) &#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//再看左边开始往右递增，找到比temp大的值才停止</span></span><br><span class="line">			<span class="keyword">while</span> ( temp&gt;=a[i] &amp;&amp; i&lt;j) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//满足 i&lt;j 就交换,继续循环while(i&lt;j)</span></span><br><span class="line">			<span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">				<span class="type">int</span> t=a[i];</span><br><span class="line">				a[i]=a[j];</span><br><span class="line">				a[j]=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后将基准位跟  a[i]与a[j]相等的位置，进行交换,此时i=j</span></span><br><span class="line">		a[low]=a[i];</span><br><span class="line">		a[i]=temp;</span><br><span class="line">		<span class="comment">//左递归</span></span><br><span class="line">		quicksort(a, low, j-<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//右递归</span></span><br><span class="line">		quicksort(a, j+<span class="number">1</span>, high);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-归并排序-Merge-Sort"><a href="#6-归并排序-Merge-Sort" class="headerlink" title="6.归并排序(Merge Sort)"></a>6.归并排序(Merge Sort)</h3><p><img src="https://img-blog.csdnimg.cn/202105062211506.gif" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210506220742403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUzMTk2Ng==,size_32,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort_06</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		<span class="comment">//int a[]=&#123;5,2,4,7,1,3,2,2&#125;;</span></span><br><span class="line">		<span class="type">int</span> temp[]=<span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">		mergesort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,temp);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergesort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">		<span class="comment">//分解</span></span><br><span class="line">		<span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">			<span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">			<span class="comment">//向左递归进行分解</span></span><br><span class="line">			mergesort(a, left, mid, temp);</span><br><span class="line">			<span class="comment">//向右递归进行分解</span></span><br><span class="line">			mergesort(a, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">			<span class="comment">//每分解一次便合并一次</span></span><br><span class="line">			merge(a,left,right,mid,temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a  待排序的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid	中间索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp	做中转的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">		<span class="type">int</span> i=left; <span class="comment">//初始i，左边有序序列的初始索引</span></span><br><span class="line">		<span class="type">int</span> j=mid+<span class="number">1</span>;<span class="comment">//初始化j，右边有序序列的初始索引（右边有序序列的初始位置即中间位置的后一位置）</span></span><br><span class="line">		<span class="type">int</span> t=<span class="number">0</span>;<span class="comment">//指向temp数组的当前索引，初始为0	</span></span><br><span class="line">	<span class="comment">//先把左右两边的数据（已经有序）按规则填充到temp数组</span></span><br><span class="line">	<span class="comment">//直到左右两边的有序序列，有一边处理完成为止</span></span><br><span class="line">	<span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right) &#123;</span><br><span class="line">		<span class="comment">//如果左边有序序列的当前元素小于或等于右边的有序序列的当前元素，就将左边的元素填充到temp数组中</span></span><br><span class="line">		<span class="keyword">if</span> (a[i]&lt;=a[j]) &#123;</span><br><span class="line">			temp[t]=a[i];</span><br><span class="line">			t++;<span class="comment">//索引向后移</span></span><br><span class="line">			i++;<span class="comment">//i后移</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//反之，将右边有序序列的当前元素填充到temp数组中</span></span><br><span class="line">			temp[t]=a[j];</span><br><span class="line">			t++;<span class="comment">//索引向后移    </span></span><br><span class="line">			j++;<span class="comment">//j后移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把剩余数据的一边的元素填充到temp中</span></span><br><span class="line">	<span class="keyword">while</span> (i&lt;=mid) &#123;</span><br><span class="line">		<span class="comment">//此时说明左边序列还有剩余元素</span></span><br><span class="line">		<span class="comment">//全部填充到temp数组</span></span><br><span class="line">		temp[t]=a[i];</span><br><span class="line">		t++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j&lt;=right) &#123;</span><br><span class="line">		<span class="comment">//此时说明左边序列还有剩余元素</span></span><br><span class="line">		<span class="comment">//全部填充到temp数组</span></span><br><span class="line">		temp[t]=a[j];</span><br><span class="line">		t++;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将temp数组的元素复制到原数组</span></span><br><span class="line">	t=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tempLeft=left;</span><br><span class="line">	<span class="keyword">while</span> (tempLeft&lt;=right) &#123;</span><br><span class="line">		a[tempLeft]=temp[t]; </span><br><span class="line">		t++;</span><br><span class="line">		tempLeft++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-堆排序-Heap-Sort"><a href="#7-堆排序-Heap-Sort" class="headerlink" title="7.堆排序(Heap Sort)"></a>7.堆排序(Heap Sort)</h3><p>第一步：构建初始堆buildHeap， 使用sink(arr,i, length)调整堆顶的值;<br>第二步：将堆顶元素下沉 目的是将最大的元素浮到堆顶来，然后使用sink(arr, 0,length)调整;</p>
<p><img src="https://img-blog.csdnimg.cn/202105161702205.gif" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap_Sort_07</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;	</span><br><span class="line">		sort(a);</span><br><span class="line">		System.out.println(Arrays.toString(a));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//构建堆</span></span><br><span class="line">        buildHeap(arr,length);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">            <span class="comment">//将堆顶元素与末位元素调换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">//数组长度-1 隐藏堆尾元素</span></span><br><span class="line">            length--;</span><br><span class="line">            <span class="comment">//将堆顶元素下沉 目的是将最大的元素浮到堆顶来</span></span><br><span class="line">            sink(arr, <span class="number">0</span>,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            sink(arr,i, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftChild</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;<span class="comment">//左子节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightChild</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;<span class="comment">//右子节点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">present</span> <span class="operator">=</span> index;<span class="comment">//要调整的节点下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉左边</span></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; length &amp;&amp; arr[leftChild] &gt; arr[present]) &#123;</span><br><span class="line">        present = leftChild;	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉右边</span></span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; length &amp;&amp; arr[rightChild] &gt; arr[present]) &#123;</span><br><span class="line">        present = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果下标不相等 证明调换过了</span></span><br><span class="line">    <span class="keyword">if</span> (present != index) &#123;</span><br><span class="line">        <span class="comment">//交换值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        arr[index] = arr[present];</span><br><span class="line">        arr[present] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//继续下沉 在取出头元素后与尾元素交换继续下沉</span></span><br><span class="line">        sink(arr, present, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-计数排序-Count-Sort"><a href="#8-计数排序-Count-Sort" class="headerlink" title="8.计数排序 (Count Sort)"></a>8.计数排序 (Count Sort)</h3><h3 id="9-桶排序-Bucket-Sort"><a href="#9-桶排序-Bucket-Sort" class="headerlink" title="9.桶排序(Bucket Sort)"></a>9.桶排序(Bucket Sort)</h3><p><img src="https://img-blog.csdnimg.cn/20210516170800145.gif" alt="在这里插入图片描述"></p>
<p>思路：</p>
<ul>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort_09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//最大最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length</span><br><span class="line"></span><br><span class="line"> <span class="title function_">for</span><span class="params">(<span class="type">int</span> i=<span class="number">1</span>; i&lt;length; i++)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//最大值和最小值的差</span></span><br><span class="line">​    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> max - min;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//桶列表</span></span><br><span class="line">​    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">​    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">​        bucketList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//每个桶的存数区间</span></span><br><span class="line">​    <span class="type">float</span> <span class="variable">section</span> <span class="operator">=</span> (<span class="type">float</span>) diff / (<span class="type">float</span>) (length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//数据入桶</span></span><br><span class="line">​    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">​        <span class="comment">//当前数除以区间得出存放桶的位置 减1后得出桶的下标</span></span><br><span class="line">​        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) (arr[i] / section) - <span class="number">1</span>;</span><br><span class="line">​        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">​            num = <span class="number">0</span>;</span><br><span class="line">​        &#125;</span><br><span class="line">​        bucketList.get(num).add(arr[i]);</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//桶内排序</span></span><br><span class="line">​    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketList.size(); i++)&#123;</span><br><span class="line">​        <span class="comment">//jdk的排序速度当然信得过</span></span><br><span class="line">​        Collections.sort(bucketList.get(i));</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">//写入原数组</span></span><br><span class="line">​    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span>(ArrayList&lt;Integer&gt; arrayList : bucketList)&#123;</span><br><span class="line">​        <span class="keyword">for</span>(<span class="type">int</span> value : arrayList)&#123;</span><br><span class="line">​            arr[index] = value;</span><br><span class="line">​            index++;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-基数排序-Raix-Sort"><a href="#10-基数排序-Raix-Sort" class="headerlink" title="10.基数排序(Raix Sort)"></a>10.基数排序(Raix Sort)</h3><h4 id="2386-找出数组的第-K-大和"><a href="#2386-找出数组的第-K-大和" class="headerlink" title="2386. 找出数组的第 K 大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/">2386. 找出数组的第 K 大和</a></h4><p>将问题转换为<img src="/2023/09/19/leecode-sum-up/2386.png" alt="image-20240308210525630"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">kSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            total += nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="type">long</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">long</span>[]&gt;((a, b) -&gt; Long.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;nums[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= k; j++) &#123;</span><br><span class="line">        <span class="type">long</span>[] arr = pq.poll();</span><br><span class="line">        <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) arr[<span class="number">1</span>];</span><br><span class="line">        ret = t;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;t + nums[i + <span class="number">1</span>], i + <span class="number">1</span>&#125;);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;t - nums[i] + nums[i + <span class="number">1</span>], i + <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total - ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LCR-170-交易逆序对的总数"><a href="#LCR-170-交易逆序对的总数" class="headerlink" title="LCR 170. 交易逆序对的总数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">LCR 170. 交易逆序对的总数</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        merge(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            merge(nums, left, mid);</span><br><span class="line">            merge(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">            mergeSort(nums, left, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temparr = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> left, temp2 = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp1 &lt;= mid &amp;&amp; temp2 &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[temp1] &lt;= nums[temp2]) &#123;</span><br><span class="line">                temparr[index++] = nums[temp1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用来统计逆序对的个数</span></span><br><span class="line">                count += (mid - temp1 + <span class="number">1</span>);</span><br><span class="line">                temparr[index++] = nums[temp2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把左边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (temp1 &lt;= mid) &#123;</span><br><span class="line">            temparr[index++] = nums[temp1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把右边剩余的数移入数组</span></span><br><span class="line">        <span class="keyword">while</span> (temp2 &lt;= right) &#123;</span><br><span class="line">            temparr[index++] = nums[temp2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; temparr.length; k++) &#123;</span><br><span class="line">            nums[k + left] = temparr[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>选择图中一个入度为0的点，记录下来</li>
<li>在图中删除该点和所有以它为起点的边</li>
<li>重复1和2，直到图为空或没有入度为0的点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">haveCircularDependency</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 邻接表存储图结构</span></span><br><span class="line">    <span class="type">int</span>[] indeg = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 每个点的入度</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储结果序列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        g.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> prerequisite[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> prerequisite[<span class="number">1</span>];</span><br><span class="line">        g.get(a).add(b);</span><br><span class="line">        indeg[b]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 一次性将入度为0的点全部入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        res.add(t);</span><br><span class="line">        <span class="comment">// 删除边时，将终点的入度-1。若入度为0，果断入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : g.get(t)) &#123;</span><br><span class="line">            indeg[j]--;</span><br><span class="line">            <span class="keyword">if</span> (indeg[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.size() == n) <span class="keyword">return</span> res; <span class="comment">// 如果结果列表大小等于节点数，说明排序成功，没有环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 否则返回空列表，表示有环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><font color="red">ps：在链表操作中不会直接使用head头节点操作而是使用一个新头指针来操作链表</font></p>
<h2 id="1、206-反转链表"><a href="#1、206-反转链表" class="headerlink" title="1、206.反转链表"></a>1、206.反转链表</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif" alt="img"></p>
<p>标准双指针问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">       ListNode* cur = head;</span><br><span class="line">       ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">           temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">           cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">           <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><font color="yellow"><strong>链表作题一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序</strong></font></p>
<h2 id="2、快慢指针法"><a href="#2、快慢指针法" class="headerlink" title="2、快慢指针法"></a>2、快慢指针法</h2><h2 id="3、环形链表判断"><a href="#3、环形链表判断" class="headerlink" title="3、环形链表判断"></a>3、环形链表判断</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif" alt="141.环形链表"></p>
<h3 id="如果有环，如何找到这个环的入口"><a href="#如果有环，如何找到这个环的入口" class="headerlink" title="如果有环，如何找到这个环的入口"></a>如果有环，如何找到这个环的入口</h3><p><strong>此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。</strong></p>
<p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 &#x3D; slow指针走过的节点数 * 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure>

<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
<p>这个公式说明什么呢？</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>同类型题目<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p>
<img src="https://pic.leetcode-cn.com/cc43daa8cbb755373ce4c5cd10c44066dc770a34a6d2913a52f8047cbf5e6e56-file_1559548337458" alt="img" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    ListNode fast=dummyNode;</span><br><span class="line">    ListNode slow=dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n  ; i++)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时 slowIndex 的位置就是待删除元素的前一个位置。</span></span><br><span class="line">    <span class="comment">//具体情况可自己画一个链表长度为 3 的图来模拟代码来理解</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></p>
<p>循环遍历直到相交</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line">    <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">        A = A != <span class="literal">null</span> ? A.next : headB;</span><br><span class="line">        B = B != <span class="literal">null</span> ? B.next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、分割链表反转"><a href="#4、分割链表反转" class="headerlink" title="4、分割链表反转"></a>4、分割链表反转</h2><p><img src="https://code-thinking.cdn.bcebos.com/pics/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="comment">//求出中点</span></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//right就是右半部分 12345 就是45  1234 就是34</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="comment">//断开左部分和右部分</span></span><br><span class="line">        slow.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//反转右部分 right就是反转后右部分的起点</span></span><br><span class="line">        right = reverseList(right);</span><br><span class="line">        <span class="comment">//左部分的起点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//进行左右部分来回连接 </span></span><br><span class="line">        <span class="comment">//这里左部分的节点个数一定大于等于右部分的节点个数 因此只判断right即可</span></span><br><span class="line">        <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">curLeft</span> <span class="operator">=</span> left.next;</span><br><span class="line">            left.next = right;</span><br><span class="line">            left = curLeft;</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">curRight</span> <span class="operator">=</span> right.next;</span><br><span class="line">            right.next = left;</span><br><span class="line">            right = curRight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">headNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = headNode.next;</span><br><span class="line">            headNode.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用虚拟构造一个头节点pre来完成对于一个新链表的创建-例如合并两个排序链表时就可以使用这个方法来创建一个新链表"><a href="#使用虚拟构造一个头节点pre来完成对于一个新链表的创建-例如合并两个排序链表时就可以使用这个方法来创建一个新链表" class="headerlink" title="使用虚拟构造一个头节点pre来完成对于一个新链表的创建  例如合并两个排序链表时就可以使用这个方法来创建一个新链表"></a>使用虚拟构造一个头节点pre来完成对于一个新链表的创建  例如合并两个排序链表时就可以使用这个方法来创建一个新链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);      </span><br><span class="line">   <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值插入新链表中</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> pre.next;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    ListNode cur=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode re=cur;</span><br><span class="line">    <span class="keyword">while</span> (l1!=<span class="literal">null</span>&amp;&amp;l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            re.next=l1;</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            re.next=l2;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        re=re.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">null</span>)&#123;</span><br><span class="line">        re.next=l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> re.next=l1;</span><br><span class="line">    <span class="keyword">return</span> cur.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h3><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序 </span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">insertionSortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode temp=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        temp.next=head;</span><br><span class="line">        ListNode sorted=head,cur=head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sorted.val&lt;=cur.val)&#123;</span><br><span class="line">                sorted=sorted.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode pre=temp;</span><br><span class="line">                <span class="keyword">while</span> (pre.next.val&lt;=cur.val)&#123;</span><br><span class="line">                    pre=pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                sorted.next=cur.next;</span><br><span class="line">                cur.next=pre.next;</span><br><span class="line">                pre.next=cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=sorted.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode slow=head,fast=head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp=slow.next;</span><br><span class="line">        slow.next=<span class="literal">null</span>;</span><br><span class="line">        ListNode left=sortList(head);</span><br><span class="line">        ListNode right=sortList(temp);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span>merge(left,right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode left,ListNode right)</span>&#123;</span><br><span class="line">        ListNode res=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode temp=res,temp1=left,temp2=right;</span><br><span class="line">        <span class="keyword">while</span> (temp1!=<span class="literal">null</span>&amp;&amp;temp2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp1.val&gt; temp2.val)&#123;</span><br><span class="line">                temp.next=temp2;</span><br><span class="line">                temp2=temp2.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next=temp1;</span><br><span class="line">                temp1=temp1.next;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp1==<span class="literal">null</span>)temp.next=temp2;</span><br><span class="line">        <span class="keyword">else</span> temp.next=temp1;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、合并k个链表"><a href="#5、合并k个链表" class="headerlink" title="5、合并k个链表"></a>5、合并k个链表</h2><p>这题就是更新于合并两个排序链表</p>
<p>将k个链表两两合并即可完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> merge(lists, left, mid);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> merge(lists, mid + <span class="number">1</span>, right);<span class="comment">//防止重复何必之前一个链表</span></span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归合并两个链表</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="8、2-两数相加"><a href="#8、2-两数相加" class="headerlink" title="8、2. 两数相加"></a>8、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><p>小tips：使用while 加||可以在内部在判断l1或者l2是否为空这样可以哪怕一边为空都可以继续循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">  <span class="comment">//此处为错误示范  while (l1!=null&amp;&amp;l2!=null)&#123;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    ListNode pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode cur=pre;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1!=<span class="literal">null</span>||l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">        <span class="type">int</span> sum=num1+num2+carry;</span><br><span class="line">        carry=sum/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> val=sum%<span class="number">10</span>;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">null</span>)l1=l1.next;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">null</span>)l2=l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后再判断是否有进位来看是否增加前缀长度</span></span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、25-K-个一组翻转链表"><a href="#7、25-K-个一组翻转链表" class="headerlink" title="7、25. K 个一组翻转链表"></a>7、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>实现关键就在于将其分组拆分后先反转链表再拼接</p>
<img src="https://pic.leetcode-cn.com/866b404c6b0b52fa02385e301ee907fc015742c3766c80c02e24ef3a8613e5ad-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt="k个一组翻转链表.png" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">hair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    hair.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> hair;</span><br><span class="line">    ListNode end=hair;</span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k&amp;&amp; end != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">            end=end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="literal">null</span>)<span class="keyword">break</span>;</span><br><span class="line">        ListNode next=end.next;</span><br><span class="line">        ListNode start=pre.next;</span><br><span class="line">        end.next=<span class="literal">null</span>;</span><br><span class="line">        pre.next=reverse(start);</span><br><span class="line">        start.next=next;</span><br><span class="line">        end=start;</span><br><span class="line">        pre=start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h3><img src="https://pic.leetcode-cn.com/1615105150-pfWiGq-image.png" alt="image.png" style="zoom: 33%;">

<p>记录pre指针位置，最后链接时pre的next链接right pre.next.next链接succ就可以</p>
<img src="https://pic.leetcode-cn.com/1615105168-ZQRZew-image.png" alt="image.png" style="zoom:33%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head), p0 = dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; ++i)</span><br><span class="line">        p0 = p0.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = p0.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre; <span class="comment">// 每次循环只修改一个 next，方便大家理解</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    p0.next.next = cur;</span><br><span class="line">    p0.next = pre;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h3><p>关键点在与将链表链接成环,先链接再斩断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">iter</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (iter.next != <span class="literal">null</span>) &#123;</span><br><span class="line">           iter = iter.next;</span><br><span class="line">           n++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> n - k % n;</span><br><span class="line">       <span class="keyword">if</span> (add == n) &#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       iter.next = head;</span><br><span class="line">       <span class="keyword">while</span> (add-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           iter = iter.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">ret</span> <span class="operator">=</span> iter.next;</span><br><span class="line">       iter.next = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>给定一个奇数位升序，偶数位降序的链表，将其重新排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortOddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode[] partitions = partition(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">oddList</span> <span class="operator">=</span> partitions[<span class="number">0</span>];</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenList</span> <span class="operator">=</span> reverse(partitions[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> merge(oddList, evenList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode[] partition(ListNode head) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head, even = evenHead;</span><br><span class="line">        <span class="keyword">while</span> (even != <span class="literal">null</span> &amp;&amp; even.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = <span class="literal">null</span>; <span class="comment">// Disconnect the odd list from the even list</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>[]&#123;head, evenHead&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> p.next;</span><br><span class="line">            p.next = dummy.next;</span><br><span class="line">            dummy.next = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode p, ListNode q)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; q != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt;= q.val) &#123;</span><br><span class="line">                r.next = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.next = q;</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="哈希map遍历"><a href="#哈希map遍历" class="headerlink" title="哈希map遍历"></a>哈希map遍历</h2><p>1、 通过ForEach循环进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Iterating entries using a For Each loop</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 ForEach迭代键值对方式<br>如果你只想使用键或者值，推荐使用如下方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 迭代键</span></span><br><span class="line">		<span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Key = &quot;</span> + key);</span><br><span class="line">		&#125;</span><br><span class="line">	 </span><br><span class="line">		<span class="comment">// 迭代值</span></span><br><span class="line">		<span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Value = &quot;</span> + value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用带泛型的迭代器进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">		Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line">		<span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">			Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用不带泛型的迭代器进行遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">		Iterator&lt;Map.Entry&gt; entries = map.entrySet().iterator();</span><br><span class="line">		<span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">			Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) entries.next();</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> (Integer) entry.getKey();</span><br><span class="line">			<span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> (Integer) entry.getValue();</span><br><span class="line">			System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、通过Java8 Lambda表达式遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">		map.forEach((k, v) -&gt; System.out.println(<span class="string">&quot;key: &quot;</span> + k + <span class="string">&quot; value:&quot;</span> + v));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computeIfAbsent-方法"><a href="#computeIfAbsent-方法" class="headerlink" title="computeIfAbsent()方法"></a>computeIfAbsent()方法</h4><p>hashMap.computeIfAbsent(“china”, key -&gt; getValues(key)).add(“liSi”);的意思表示key为“China”的建值对是否存在，返回的是value的值。</p>
<p>如果存在则获取china的值，并操作值的set添加数据“lisi”。</p>
<p>如果不存在，则调用方法，新创建set结构，将”lisi”添加到set中，再存入到hashMap中</p>
<h4 id="2808-使循环数组所有元素相等的最少秒数"><a href="#2808-使循环数组所有元素相等的最少秒数" class="headerlink" title="2808. 使循环数组所有元素相等的最少秒数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/">2808. 使循环数组所有元素相等的最少秒数</a></h4><p>破题关键在于第一破除环形数组，在正常数组背后加头元素成为链式数组 ，第二找到两个相同的元素离得最远的距离除以二就是就是传播所需要的长时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSeconds</span><span class="params">(List&lt;Integer&gt; nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    Map&lt;Integer,List&lt;Integer&gt;&gt;map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">        map.computeIfAbsent(nums.get(i), k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=size;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; a : map.values()) &#123;</span><br><span class="line">        a.add(a.get(<span class="number">0</span>) + size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">            mx = Math.max(mx, (a.get(i) - a.get(i - <span class="number">1</span>)) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.min(res, mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1、基本哈希映射"><a href="#1、基本哈希映射" class="headerlink" title="1、基本哈希映射"></a>1、基本哈希映射</h2><h2 id="2、字母相同哈希思路"><a href="#2、字母相同哈希思路" class="headerlink" title="2、字母相同哈希思路"></a>2、字母相同哈希思路</h2><p><font color="red"><strong>开一个int hash[26]进行哈希映射，之后选择取min来完成相同字母的统计</strong></font></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/1002.%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.png" alt="1002.查找常用字符"></p>
<h2 id="3、多数之和"><a href="#3、多数之和" class="headerlink" title="3、多数之和"></a>3、多数之和</h2><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一"></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];   <span class="comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">            res[<span class="number">1</span>] = i;</span><br><span class="line">            res[<span class="number">0</span>] = map.get(temp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);    <span class="comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>四数相加同理将两个数分组然后使用哈希匹配</strong></font></p>
<h2 id="4、s三数之和以上不适合用哈希-使用双指针法完成"><a href="#4、s三数之和以上不适合用哈希-使用双指针法完成" class="headerlink" title="4、s三数之和以上不适合用哈希 使用双指针法完成"></a>4、s三数之和以上不适合用哈希 使用双指针法完成</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>对数组先进行升序排序</p>
<p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。</p>
<p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p>
<p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p>
<h2 id="5、hashset去重"><a href="#5、hashset去重" class="headerlink" title="5、hashset去重"></a>5、hashset去重</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<p>从小的开始去找大的跳过大的数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; num_set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            num_set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">longestStreak</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : num_set) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!num_set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentStreak</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (num_set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                currentNum += <span class="number">1</span>;</span><br><span class="line">                currentStreak += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="355-设计推特"><a href="#355-设计推特" class="headerlink" title="355. 设计推特"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-twitter/">355. 设计推特</a></h3><p>纯模拟题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户 id 和推文（单链表）的对应关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Tweet&gt; twitter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户 id 和他关注的用户列表的对应关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; followings;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局使用的时间戳字段，用户每发布一条推文之前 + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并 k 组推文使用的数据结构（可以在方法里创建使用），声明成全局变量非必需，视个人情况使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> PriorityQueue&lt;Tweet&gt; maxHeap;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Twitter</span><span class="params">()</span> &#123;</span><br><span class="line">    followings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    twitter = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; -o1.timestamp + o2.timestamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postTweet</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> tweetId)</span> &#123;</span><br><span class="line">        timestamp++;</span><br><span class="line">    <span class="keyword">if</span> (twitter.containsKey(userId)) &#123;</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">oldHead</span> <span class="operator">=</span> twitter.get(userId);</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, timestamp);</span><br><span class="line">        newHead.next = oldHead;</span><br><span class="line">        twitter.put(userId, newHead);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        twitter.put(userId, <span class="keyword">new</span> <span class="title class_">Tweet</span>(tweetId, timestamp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getNewsFeed</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 由于是全局使用的，使用之前需要清空</span></span><br><span class="line">    maxHeap.clear();</span><br><span class="line">    <span class="comment">// 如果自己发了推文也要算上</span></span><br><span class="line">    <span class="keyword">if</span> (twitter.containsKey(userId)) &#123;</span><br><span class="line">        maxHeap.offer(twitter.get(userId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; followingList = followings.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (followingList != <span class="literal">null</span> &amp;&amp; followingList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer followingId : followingList) &#123;</span><br><span class="line">            <span class="type">Tweet</span> <span class="variable">tweet</span> <span class="operator">=</span> twitter.get(followingId);</span><br><span class="line">            <span class="keyword">if</span> (tweet != <span class="literal">null</span>) &#123;</span><br><span class="line">                maxHeap.offer(tweet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="type">Tweet</span> <span class="variable">head</span> <span class="operator">=</span> maxHeap.poll();</span><br><span class="line">        res.add(head.id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里最好的操作应该是 replace，但是 Java 没有提供</span></span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            maxHeap.offer(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (followeeId == followerId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取我自己的关注列表</span></span><br><span class="line">    Set&lt;Integer&gt; followingList  = followings.get(followerId);</span><br><span class="line">    <span class="keyword">if</span>(followingList==<span class="literal">null</span>)&#123;</span><br><span class="line">        Set&lt;Integer&gt; init = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        init.add(followeeId);</span><br><span class="line">        followings.put(followerId, init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (followingList.contains(followeeId)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里删除之前无需做判断，因为查找是否存在以后，就可以删除，反正删除之前都要查找</span></span><br><span class="line">        followingList.add(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unfollow</span><span class="params">(<span class="type">int</span> followerId, <span class="type">int</span> followeeId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(followeeId==followerId)<span class="keyword">return</span>;</span><br><span class="line">        Set&lt;Integer&gt;followinglist=followings.get(followerId);</span><br><span class="line">        <span class="keyword">if</span>(followinglist==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        followinglist.remove(followeeId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推文 id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发推文的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timestamp;</span><br><span class="line">    <span class="keyword">private</span> Tweet next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timestamp)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两数异或"><a href="#两数异或" class="headerlink" title="两数异或"></a>两数异或</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></p>
<h4 id="2935-找出强数对的最大异或值-II"><a href="#2935-找出强数对的最大异或值-II" class="headerlink" title="2935. 找出强数对的最大异或值 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/">2935. 找出强数对的最大异或值 II</a></h4><p>以上两题是类似于两数之和的两数异或判断</p>
<img src="https://pic.leetcode.cn/1698978713-ouzPib-lc421-c.png" alt="lc421-c.png" style="zoom: 33%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        max = Math.max(max, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">highBit</span> <span class="operator">=</span> <span class="number">31</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> highBit; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从最高位开始枚举</span></span><br><span class="line">        seen.clear();</span><br><span class="line">        mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newAns</span> <span class="operator">=</span> ans | (<span class="number">1</span> &lt;&lt; i); <span class="comment">// 这个比特位可以是 1 吗？</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            x &amp;= mask; <span class="comment">// 低于 i 的比特位置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (seen.contains(newAns ^ x)) &#123;</span><br><span class="line">                ans = newAns; <span class="comment">// 这个比特位可以是 1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumStrongPairXor</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">highBit</span> <span class="operator">=</span> <span class="number">31</span> - Integer.numberOfLeadingZeros(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, mask = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> highBit; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从最高位开始枚举</span></span><br><span class="line">            mp.clear();</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newAns</span> <span class="operator">=</span> ans | (<span class="number">1</span> &lt;&lt; i); <span class="comment">// 这个比特位可以是 1 吗？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : nums) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">maskY</span> <span class="operator">=</span> y &amp; mask; <span class="comment">// 低于 i 的比特位置为 0</span></span><br><span class="line">                <span class="keyword">if</span> (mp.containsKey(newAns ^ maskY) &amp;&amp; mp.get(newAns ^ maskY) * <span class="number">2</span> &gt;= y) &#123;</span><br><span class="line">                    ans = newAns; <span class="comment">// 这个比特位可以是 1</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mp.put(maskY, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="828-统计子串中的唯一字符"><a href="#828-统计子串中的唯一字符" class="headerlink" title="828. 统计子串中的唯一字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符</a></h3><img src="https://pic.leetcode-cn.com/1662480137-TJiyfu-1.png" alt="1.png" style="zoom:67%;">

<p>这题需要找到这个计算规律将寻找字符频数转换为区间内次数计算</p>
<img src="https://pic.leetcode-cn.com/1662435980-lzhQam-1.png" alt="1.png" style="zoom:50%;">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniqueLetterString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sc.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(sc[i])) map.put(sc[i], <span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">            map.get(sc[i]).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(Map.Entry&lt;Character, List&lt;Integer&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> -<span class="number">1</span>, tail = -<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; item = entry.getValue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; item.size(); i++) &#123;</span><br><span class="line">            tail = (i &lt; item.size() - <span class="number">1</span>) ? item.get(i + <span class="number">1</span>) : sc.length;</span><br><span class="line">            result += (item.get(i) - head) * (tail - item.get(i));</span><br><span class="line">            head = item.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-方法1：char-数组转成String，使用-String-类的-valueOf-方法"><a href="#1-方法1：char-数组转成String，使用-String-类的-valueOf-方法" class="headerlink" title="1.方法1：char[]数组转成String，使用 String 类的 valueOf() 方法"></a>1.方法1：char[]数组转成String，使用 String 类的 valueOf() 方法</h2><p><strong>我们可以使用 String 类的 String.valueOf(char) 方法和 Character 类的 Character.toString(char) 方法在 java 中将 char 转换为 String。</strong></p>
<h3 id="String-valueOf-char-方法和-Character-类的-Character-toString-char-方法的区别："><a href="#String-valueOf-char-方法和-Character-类的-Character-toString-char-方法的区别：" class="headerlink" title="String.valueOf(char) 方法和 Character 类的 Character.toString(char)方法的区别："></a>String.valueOf(char) 方法和 Character 类的 Character.toString(char)方法的区别：</h3><h4 id="1-String-valueOf-char-方法可以将char-和char-变量名转成String类型"><a href="#1-String-valueOf-char-方法可以将char-和char-变量名转成String类型" class="headerlink" title="1.String.valueOf(char) 方法可以将char[] 和char 变量名转成String类型"></a>1.String.valueOf(char) 方法可以将char[] 和char 变量名转成String类型</h4><h3 id="2-Character-toString-char-方法只能在char-变量名转成String类型"><a href="#2-Character-toString-char-方法只能在char-变量名转成String类型" class="headerlink" title="2.Character.toString(char)方法只能在char 变量名转成String类型"></a>2.Character.toString(char)方法只能在char 变量名转成String类型</h3><h2 id="2、字符翻转"><a href="#2、字符翻转" class="headerlink" title="2、字符翻转"></a>2、字符翻转</h2><p>本质就是双指针对于前面字符交换</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.gif" alt="344.反转字符串"></p>
<p>在遇到交换k位之后的字符时，思路为翻转后k个再翻转前k个最后翻转整个字符</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="img"></p>
<h3 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796. 旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-string/">796. 旋转字符串</a></h3><p><img src="https://pic.leetcode-cn.com/1638612131-tGESRo-ccw-01-09.005.png" alt="ccw-01-09.005.png"></p>
<h2 id="3、kmp算法"><a href="#3、kmp算法" class="headerlink" title="3、kmp算法"></a>3、kmp算法</h2><h3 id="（1）KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。"><a href="#（1）KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。" class="headerlink" title="（1）KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。"></a>（1）KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></h3><h3 id="（2）所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。"><a href="#（2）所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。" class="headerlink" title="（2）所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。"></a>（2）所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</h3><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p>
<h3 id="（3）如何计算前缀表"><a href="#（3）如何计算前缀表" class="headerlink" title="（3）如何计算前缀表"></a>（3）如何计算前缀表</h3><p>接下来就要说一说怎么计算前缀表。</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B25.png" alt="KMP精讲5"></p>
<p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B26.png" alt="KMP精讲6"></p>
<p>长度为前2个字符的子串<code>aa</code>，最长相同前后缀的长度为1。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B27.png" alt="KMP精讲7"></p>
<p>长度为前3个字符的子串<code>aab</code>，最长相同前后缀的长度为0。</p>
<p>以此类推： 长度为前4个字符的子串<code>aaba</code>，最长相同前后缀的长度为1。 长度为前5个字符的子串<code>aabaa</code>，最长相同前后缀的长度为2。 长度为前6个字符的子串<code>aabaaf</code>，最长相同前后缀的长度为0。</p>
<p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/KMP%E7%B2%BE%E8%AE%B28.png" alt="KMP精讲8"></p>
<p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p>
<p>再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"></p>
<p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p>
<p>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p>
<p>所以要看前一位的 前缀表的数值。</p>
<p>前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p>
<p>最后就在文本串中找到了和模式串匹配的子串了。</p>
<p>其实<strong>这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      next[<span class="number">0</span>] = j;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">          <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">              j=next[j];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(s.charAt(i) == s.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          next[i] = j;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(needle.length()==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">      getNext(next, needle);</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++)&#123;</span><br><span class="line">          <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">              j = next[j];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(j == needle.length()-<span class="number">1</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> (i-needle.length()+<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2851-字符串转换"><a href="#2851-字符串转换" class="headerlink" title="2851. 字符串转换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-transformation/">2851. 字符串转换</a></h3><p>操作等价于把末尾字母一个一个地移到开头，比如字符串 abcd，「把 cd 移到开头」和「先把 d 移到开头，再把 c 移到开头」，都会得到字符串 cdab。</p>
<p>所以操作得到的是 sss 的循环同构字符串，这意味着，只要 s+s中包含 t，就可以从 sss 变成 t。比如示例 1 的 s+s&#x3D;abcdabcd，其中就包含一个 cdab。</p>
<p>计算有多少个 sss 的循环同构字符串等于 t，记作 ccc。这可以用 KMP 等字符串匹配算法解决，即寻找 ttt 在 s+ss+ss+s（去掉最后一个字符）中的出现次数。例如示例 2 中 c&#x3D;3。</p>
<p><img src="/2023/09/19/leecode-sum-up/2851.png" alt="image-20240219203048533"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWays</span><span class="params">(String s, String t, <span class="type">long</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> kmpSearch(s + s.substring(<span class="number">0</span>, n - <span class="number">1</span>), t);<span class="comment">//避免统计最后一个字母</span></span><br><span class="line">    <span class="type">long</span>[][] m = &#123;</span><br><span class="line">        &#123;c - <span class="number">1</span>, c&#125;,</span><br><span class="line">        &#123;n - c, n - <span class="number">1</span> - c&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    m = pow(m, k);</span><br><span class="line">    <span class="keyword">return</span> s.equals(t) ? (<span class="type">int</span>) m[<span class="number">0</span>][<span class="number">0</span>] : (<span class="type">int</span>) m[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 模板</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] calcMaxMatch(String s) &#123;</span><br><span class="line">    <span class="type">int</span>[] match = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">v</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; s.charAt(c) != v) &#123;</span><br><span class="line">            c = match[c - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(c) == v) &#123;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        match[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 模板</span></span><br><span class="line"><span class="comment">// 返回 text 中出现了多少次 pattern（允许 pattern 重叠）</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">kmpSearch</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] match = calcMaxMatch(pattern);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenP</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">matchCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">v</span> <span class="operator">=</span> text.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (c &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(c) != v) &#123;</span><br><span class="line">            c = match[c - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(c) == v) &#123;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == lenP) &#123;</span><br><span class="line">            matchCnt++;</span><br><span class="line">            c = match[c - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchCnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[][] multiply(<span class="type">long</span>[][] a, <span class="type">long</span>[][] b) &#123;</span><br><span class="line">    <span class="type">long</span>[][] c = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            c[i][j] = (a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵快速幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[][] pow(<span class="type">long</span>[][] a, <span class="type">long</span> n) &#123;</span><br><span class="line">    <span class="type">long</span>[][] res = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n /= <span class="number">2</span>) &#123;<span class="comment">//二分法求幂</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = multiply(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a = multiply(a, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-Z-函数（扩展-KMP）"><a href="#4-Z-函数（扩展-KMP）" class="headerlink" title="4.Z 函数（扩展 KMP）"></a>4.Z 函数（扩展 KMP）</h2><p>对于个长度为 <strong>n</strong> 的字符串s。定义函数 **z[i]**表示 s 和 **s[i,n-1]**（即以 <strong>s[i]<strong>开头的后缀）的最长公共前缀（LCP）的长度。z被称为 <strong>s</strong>的 <strong>Z 函数</strong>。特别地，</strong>z[0] &#x3D; 0</strong></p>
<p><a target="_blank" rel="noopener" href="https://personal.utdallas.edu/~besp/demo/John2010/z-algorithm.htm">Z Algorithm (JavaScript Demo) (utdallas.edu)</a></p>
<p>![image-20240204141139159](.&#x2F;leecode-sum-up&#x2F;Z Algorithm.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTimeToInitialState</span><span class="params">(String S, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s = S.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">    <span class="type">int</span>[] z = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= r) &#123;</span><br><span class="line">            z[i] = Math.min(z[i - l], r - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) &#123;</span><br><span class="line">            l = i;</span><br><span class="line">            r = i + z[i];</span><br><span class="line">            z[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i % k == <span class="number">0</span> &amp;&amp; z[i] &gt;= n - i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i / k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (n - <span class="number">1</span>) / k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5、状态机"><a href="#5、状态机" class="headerlink" title="5、状态机"></a>5、状态机</h2><p><img src="https://pic.leetcode-cn.com/6f41d7e46fd0344c013980e3f46429dd7a7311bb4292783a482466a90f15747b-Picture1.png" alt="Picture1.png"></p>
<h2 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><p>此题有个记录字符串字符出现频率的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masks[i] |= <span class="number">1</span> &lt;&lt; (word.charAt(j) - <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于字符 ‘a’：<code>1 &lt;&lt; (word.charAt(j) - &#39;a&#39;)</code> 计算为 <code>1 &lt;&lt; 0</code>，结果是 <code>1</code>（二进制：0000 0001）。</p>
</li>
<li><p>对于字符 ‘b’：<code>1 &lt;&lt; (word.charAt(j) - &#39;a&#39;)</code> 计算为 <code>1 &lt;&lt; 1</code>，结果是 <code>2</code>（二进制：0000 0010）。</p>
</li>
<li><p>对于字符 ‘c’：<code>1 &lt;&lt; (word.charAt(j) - &#39;a&#39;)</code> 计算为 <code>1 &lt;&lt; 2</code>，结果是 <code>4</code>（二进制：0000 0100）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] masks = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">wordLength</span> <span class="operator">=</span> word.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wordLength; j++) &#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (word.charAt(j) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxProd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    maxProd = Math.max(maxProd, words[i].length() * words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="670-最大交换"><a href="#670-最大交换" class="headerlink" title="670. 最大交换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-swap/">670. 最大交换</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = String.valueOf(num).toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIdx</span> <span class="operator">=</span> chars.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> low=-<span class="number">1</span>,high=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length-<span class="number">2</span>; i &gt;=<span class="number">0</span> ;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[i]&gt;chars[maxIdx])</span><br><span class="line">        &#123;</span><br><span class="line">            maxIdx=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(chars[i] &lt; chars[maxIdx])&#123; <span class="comment">// s[i] 右边有比它大的</span></span><br><span class="line">             low=i;</span><br><span class="line">             high= maxIdx; <span class="comment">// 更新 p 和 q</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low == -<span class="number">1</span>) &#123; <span class="comment">// 这意味着 s 是降序的</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> s=chars[low];</span><br><span class="line">    chars[low]=chars[high];</span><br><span class="line">    chars[high]=s;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(String.valueOf(chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>add &amp; push</p>
<p><strong>共同点：</strong></p>
<p>add，push都可以向stack中添加元素。</p>
<p><strong>不同点：</strong></p>
<p>add是继承自Vector的方法，且返回值类型是boolean。</p>
<p>push是Stack自身的方法，返回值类型是参数类类型。</p>
<p>具体的看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">     addElement(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>peek &amp; pop</p>
<p><strong>共同点：</strong></p>
<p>peek，pop都是返回栈顶元素。</p>
<p><strong>不同点：</strong></p>
<p>peek()函数返回栈顶的元素，但不弹出该栈顶元素。<br>pop()函数返回栈顶的元素，并且将该栈顶元素出栈。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></p>
<p>此题关键在于栈存放数字在遍历到符号时取出数字运算即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt;caculate=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;tokens.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(tokens[i])) &#123;        <span class="comment">// leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span></span><br><span class="line">               caculate.push(caculate.pop() + caculate.pop());      <span class="comment">// 注意 - 和/ 需要特殊处理</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">               caculate.push(-caculate.pop() + caculate.pop());</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">               caculate.push(caculate.pop() * caculate.pop());</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(tokens[i])) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> caculate.pop();</span><br><span class="line">               <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> caculate.pop();</span><br><span class="line">               caculate.push(temp2 / temp1);</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               caculate.push(Integer.valueOf(tokens[i]));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> caculate.pop();</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></p>
<p>此题在于使用stack存储数组下标这样在栈中取出时自然可以定位第几天的前面的最高温是多少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">    res[stack.peek()]=i-stack.peek();</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/car-fleet/">853. 车队</a></p>
<p>抓住一个思想，如果你位置在我前面，最终到达时间比我慢我们两个之间就会相遇，即使两个车相遇但是以最慢的那个车速度来行驶，行驶时间都是最慢那个车的最长时间，所以继续用那个车的最长时间来进行比较看是否会有二次相遇.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意此处需要使用TreeMap才能实现对于hash表的顺序输出 还要注意抓换spd数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">carFleet</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] position, <span class="type">int</span>[] speed)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt;map=<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; position.length; i++) &#123;</span><br><span class="line">            map.put(position[i],speed[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Float&gt;stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">spd</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="type">float</span> time=(<span class="type">float</span>) (target-pos)/(<span class="type">float</span>)spd;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;time&gt;=stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                System.out.println(stack.size());</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><strong>1、add()和offer()区别:</strong></p>
<p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p>
<p> <strong>2、poll()和remove()区别：</strong></p>
<p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<p><strong>3、element() 和 peek() 区别：</strong></p>
<p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。<br>下面是Java中Queue的一些常用方法：<br>add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常<br>offer       添加一个元素并返回true        如果队列已满，则返回false<br>poll         移除并返问队列头部的元素     如果队列为空，则返回null<br>peek       返回队列头部的元素              如果队列为空，则返回null<br>put         添加一个元素                       如果队列满，则阻塞<br>take        移除并返回队列头部的元素     如果队列为空，则阻塞</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">       PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a></h3><p>贪心 + 优先队列,在遍历房间的过程中，如果 nums[i]为负数，我们将其放入一个小根堆（优先队列）中。当计算完第 i 个房间的生命值影响后，如果生命值小于等于 0，那么我们取出堆顶元素，表示将该房间调整至末尾，并将其补回生命值中。由于一定会从小根堆中取出一个小于等于 nums[i] 的值，因此调整完成后，生命值一定大于 0。</p>
<p>当所有房间遍历完成后，我们还需要将所有从堆中取出元素的和重新加入生命值，如果生命值小于等于 0，说明无解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">magicTower</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt;queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> back=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>)queue.add(num);</span><br><span class="line">        cur+=num;</span><br><span class="line">        <span class="keyword">if</span>(cur&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> n=queue.poll();</span><br><span class="line">            cur-=n;</span><br><span class="line">            back+=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur+=back;</span><br><span class="line">    <span class="keyword">return</span> cur&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用例子利用大小顶堆反复跳实现对于队列的排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt;min=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt;max=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    295. 数据流的中位数  https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&amp;envId=top-100-liked</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        min = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (b - a));</span><br><span class="line">        max = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; (a - b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.isEmpty()||num&lt;=min.peek())&#123;</span><br><span class="line">            min.offer(num);</span><br><span class="line">            <span class="keyword">if</span>(max.size()+<span class="number">1</span>&lt;min.size())&#123;</span><br><span class="line">                max.offer(min.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max.offer(num);</span><br><span class="line">            <span class="keyword">if</span>(min.size()+<span class="number">1</span>&lt;max.size())&#123;</span><br><span class="line">                min.offer(max.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(max.size()&lt;min.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> min.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max.peek()+min.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="373-查找和最小的-K-对数字"><a href="#373-查找和最小的-K-对数字" class="headerlink" title="373. 查找和最小的 K 对数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></h3><p>此题使用PriorityQueue来完成 对于插入数字的排序 为了方便操作并且字符是已经排好序的我们选用字符索引作为priorityqueue的存储数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> m=nums1.length;</span><br><span class="line">    <span class="type">int</span> n=nums2.length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt;queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span>  nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] - nums1[b[<span class="number">0</span>]] - nums2[b[<span class="number">1</span>]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Math.min(m, k); i++) &#123;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k--&gt;<span class="number">0</span>&amp;&amp;!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span>[] idxPair = queue.poll();</span><br><span class="line">        List&lt;Integer&gt;group=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        group.add(nums1[idxPair[<span class="number">0</span>]]);</span><br><span class="line">        group.add(nums2[idxPair[<span class="number">1</span>]]);</span><br><span class="line">        res.add(group);</span><br><span class="line">        <span class="keyword">if</span>(idxPair[<span class="number">1</span>]+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;idxPair[<span class="number">0</span>],idxPair[<span class="number">1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="辅助栈法"><a href="#辅助栈法" class="headerlink" title="辅助栈法"></a>辅助栈法</h3><h4 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h4><ol>
<li><p><strong>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</strong></p>
</li>
<li><p><strong>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</strong></p>
</li>
<li><p><strong>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</strong></p>
</li>
<li><p><strong>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</strong></p>
</li>
</ol>
<p><img src="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif" alt="fig1"></p>
<h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><ol>
<li><strong>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</strong></li>
<li><strong>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</strong></li>
<li><strong>当 c 为字母时，在 res 尾部添加 c；</strong></li>
<li><strong>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 000：</strong></li>
<li><strong>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</strong></li>
<li><strong>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。</strong></li>
<li><strong>进入到新 [ 后，res 和 multi 重新记录。</strong></li>
<li><strong>当 c 为 ] 时，stack 出栈，拼接字符串 res &#x3D; last_res + cur_multi * res，其中:</strong></li>
<li><strong>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</strong></li>
<li><strong>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。</strong></li>
<li><strong>返回字符串 res。</strong></li>
</ol>
<p><font color="red">使用辅助的栈帮忙存储每一层的字符结果这样可以将其递归返回到上一层输出</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">       <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       LinkedList&lt;Integer&gt; stack_multi = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       LinkedList&lt;String&gt; stack_res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">           <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">               stack_multi.addLast(multi);</span><br><span class="line">               stack_res.addLast(res.toString());</span><br><span class="line">               multi = <span class="number">0</span>;</span><br><span class="line">               res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">               <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="type">int</span> <span class="variable">cur_multi</span> <span class="operator">=</span> stack_multi.removeLast();</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur_multi; i++) tmp.append(res);</span><br><span class="line">               res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack_res.removeLast() + tmp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="keyword">else</span> res.append(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>两种思路如果使用栈则是按照行求</p>
<p><img src="https://pic.leetcode-cn.com/a6e7991ce6497ac56cb5fdd2fae18cedba5881d7c677fb7dd41442843c9c7771-image.png" alt="image.png"></p>
<p><img src="https://pic.leetcode-cn.com/dcbea3c3418c57db4a582003dafc476e91b9f48bdf511727cfa5335d392d8566-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        st.push(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; height[i] &gt; height[st.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> st.peek();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (!st.empty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[st.peek()], height[i]) - height[mid];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - st.peek() - <span class="number">1</span>;</span><br><span class="line">                    sum += h * w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果使用双指针则是按照列来求, 每次计算相邻两个列的差值只要最右边有高于左边的水就一定留得住</p>
<p><img src="https://pic.leetcode-cn.com/542754f4431d93141920185252aee31664a96dd17285b92dfe390e9e977bebb1-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> leftheight=height[left],rightheight=height[right];</span><br><span class="line">    <span class="type">int</span> leftmax=<span class="number">0</span>,rightmax=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">       leftmax=Math.max(leftmax,height[left]);</span><br><span class="line">       rightmax=Math.max(rightmax,height[right]);</span><br><span class="line">       <span class="keyword">if</span>(leftmax&lt;rightmax)&#123;</span><br><span class="line">           sum+=leftmax-height[left]; </span><br><span class="line">           left++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           sum+=rightmax-height[right];</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621. 任务调度器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="comment">//统计每个任务出现的次数，找到出现次数最多的任务</span></span><br><span class="line">       <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length; ++i) &#123;</span><br><span class="line">           hash[tasks[i] - <span class="string">&#x27;A&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(hash);</span><br><span class="line">       <span class="comment">//因为相同元素必须有n个冷却时间，假设A出现3次，n = 2，任务要执行完，至少形成AXX AXX A序列（X看作预占位置）</span></span><br><span class="line">       <span class="comment">//该序列长度为</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> (n+<span class="number">1</span>) *  (hash[<span class="number">25</span>] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//此时为了尽量利用X所预占的空间（贪心）使得整个执行序列长度尽量小，将剩余任务往X预占的空间插入</span></span><br><span class="line">       <span class="comment">//剩余的任务次数有两种情况：</span></span><br><span class="line">       <span class="comment">//1.与A出现次数相同，比如B任务最优插入结果是ABX ABX AB，中间还剩两个空位，当前序列长度+1</span></span><br><span class="line">       <span class="comment">//2.比A出现次数少，若还有X，则按序插入X位置，比如C出现两次，形成ABC ABC AB的序列</span></span><br><span class="line">       <span class="comment">//直到X预占位置还没插满，剩余元素逐个放入X位置就满足冷却时间至少为n</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">24</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(hash[i] == hash[<span class="number">25</span>]) ++ minLen;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当所有X预占的位置插满了怎么办？</span></span><br><span class="line">       <span class="comment">//在任意插满区间（这里是ABC）后面按序插入剩余元素，比如ABCD ABCD发现D之间距离至少为n+1，肯定满足冷却条件</span></span><br><span class="line">       <span class="comment">//因此，当X预占位置能插满时，最短序列长度就是task.length，不能插满则取最少预占序列长度</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(minLen, tasks.length);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="502-IPO"><a href="#502-IPO" class="headerlink" title="502. IPO"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ipo/">502. IPO</a></h3><p>此题思路为银行家算法先从小满足能够获取的资源，然后经可能在最小资源中选取最大的获利</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=profits.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> eff[][]=<span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">            eff[i][<span class="number">0</span>]=capital[i];</span><br><span class="line">            eff[i][<span class="number">1</span>]=profits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(eff,(a,b)-&gt;&#123;<span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];&#125;);</span><br><span class="line">        PriorityQueue&lt;Integer&gt;queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr&lt;n&amp;&amp;eff[curr][<span class="number">0</span>]&lt;=w)&#123;</span><br><span class="line">                queue.add(eff[curr][<span class="number">1</span>]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                w += queue.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">       queue.add(<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i&lt;s.length()) &#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)i++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">               pre=queue.peek();</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">               pre=-queue.peek();</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               queue.push(pre);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">               queue.pop();</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">long</span> num=<span class="number">0</span>;</span><br><span class="line">               <span class="keyword">while</span> (i&lt;s.length()&amp;&amp;Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                   num=num*<span class="number">10</span>+s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               res+=num*pre;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>计算器类题通用模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级</span></span><br><span class="line">    <span class="comment">// 这里的优先级划分按照「数学」进行划分即可</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) ans = a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)  ans = a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) ans = (<span class="type">int</span>)Math.pow(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) ans = a % b;</span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a><font color="red">递归三要素</font></h2><ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h2 id="1、树的遍历方式"><a href="#1、树的遍历方式" class="headerlink" title="1、树的遍历方式"></a>1、树的遍历方式</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root.left,list);</span><br><span class="line">    postorder(root.right,list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">frontorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    frontorder(root.left,list);</span><br><span class="line">    frontorder(root.right,list);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">midorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    midorder(root.left,list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    frontorder(root.right,list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200808200338924.png" alt="前序到后序"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span>  &#123;</span><br><span class="line">       List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历 注意二叉树中序遍历风格与前后序遍历不统一</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);<span class="comment">//反转先序遍历</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//层序遍历 使用队列辅助遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            itemList.add(tmpNode.val);</span><br><span class="line">            <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">            <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        resList.add(itemList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  resList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ps-层序遍历变种"><a href="#Ps-层序遍历变种" class="headerlink" title="Ps:层序遍历变种"></a>Ps:层序遍历变种</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>使用LinkedList实现对于队列的反转插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(!isEven) item.addLast(root.val);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">else</span> item.addFirst(root.val);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历解决，关键思想是：如果遍历到了一个非空节点之前遍历过空节点，那么为false，否则遍历完毕返回true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">  Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       deque.addLast(root);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">          <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.pollLast();</span><br><span class="line">          <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">              flag = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">// 如果在非空节点前出现了空节点那么则为false</span></span><br><span class="line">              <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              deque.addFirst(node.left);</span><br><span class="line">              deque.addFirst(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>两个类型一致的题目关键点在于先从先序遍历&#x2F;后序遍历找到树的头结点 然后再去拆分其左右子树范围再递归创建左右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#后序 </span><br><span class="line"><span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                            postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                            postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#先序</span><br><span class="line"><span class="keyword">if</span> (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(preorder[preBegin]);  <span class="comment">// 找到前序遍历的第一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定前序数列的个数</span></span><br><span class="line">        root.left = findNode(preorder, preBegin + <span class="number">1</span>, preBegin + lenOfLeft + <span class="number">1</span>,</span><br><span class="line">                            inorder, inBegin, rootIndex);</span><br><span class="line">        root.right = findNode(preorder, preBegin + lenOfLeft + <span class="number">1</span>, preEnd,</span><br><span class="line">                            inorder, rootIndex + <span class="number">1</span>, inEnd);</span><br></pre></td></tr></table></figure>

<h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><p>其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历</p>
<p>树可以构造，答案不唯一 也是找到后序遍历切入点找到左右子树长度创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">    Map&lt;Integer, Integer&gt; postMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        postMap.put(postorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(preorder, postorder, postMap, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder, Map&lt;Integer, Integer&gt; postMap, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> postLeft, <span class="type">int</span> postRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &lt; preRight) &#123;</span><br><span class="line">            leftCount = postMap.get(preorder[preLeft + <span class="number">1</span>]) - postLeft + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preLeft],</span><br><span class="line">                dfs(preorder, postorder, postMap, preLeft + <span class="number">1</span>, preLeft + leftCount, postLeft, postLeft + leftCount - <span class="number">1</span>),</span><br><span class="line">                dfs(preorder, postorder, postMap, preLeft + leftCount + <span class="number">1</span>, preRight, postLeft + leftCount, postRight - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2641-二叉树的堂兄弟节点-II"><a href="#2641-二叉树的堂兄弟节点-II" class="headerlink" title="2641. 二叉树的堂兄弟节点 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cousins-in-binary-tree-ii/">2641. 二叉树的堂兄弟节点 II</a></h3><p>此题使用两遍dfs 第一遍算出每一层的节点值的和，第二次dfs时用每层和减去本节点的非兄弟节点的值的和就是替换的兄弟节点值的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;sum=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">replaceValueInTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">dfs1(root,<span class="number">0</span>);</span><br><span class="line">root.val=<span class="number">0</span>;</span><br><span class="line">dfs2(root,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(TreeNode root,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum.size()&lt;=depth)</span><br><span class="line">    &#123;</span><br><span class="line">        sum.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sum.set(depth, sum.get(depth) + root.val);</span><br><span class="line">    dfs1(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    dfs1(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=node.left==<span class="literal">null</span>?<span class="number">0</span>:node.left.val;</span><br><span class="line">    <span class="type">int</span> r=node.right==<span class="literal">null</span>?<span class="number">0</span>:node.right.val;</span><br><span class="line">    <span class="type">int</span> add=l+r;</span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        node.left.val=sum.get(depth)-add;</span><br><span class="line">        dfs2(node.left,depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        node.right.val=sum.get(depth)-add;</span><br><span class="line">        dfs2(node.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>此题思想是从下层的子节点的祖先找起一层层返回判断左右节点是否都存在公共祖先如果存在则返回当前节点，如果不存在返回存在节点的祖先</p>
<p><img src="https://pic.leetcode-cn.com/1599885247-mgYjRv-Picture2.png" alt="Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==p||root==q||root==<span class="literal">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 1 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"><span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line">            </span><br><span class="line"> <span class="comment">//将 2 的左子树插入到右子树的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line">        </span><br><span class="line"> <span class="comment">//将原来的右子树接到左子树的最右边节点</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root !=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (pre.right!=<span class="literal">null</span>)pre=pre.right;</span><br><span class="line">            pre.right=root.right;</span><br><span class="line">            root.right=root.left;</span><br><span class="line">            root.left=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    root=root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、特殊二叉树"><a href="#2、特殊二叉树" class="headerlink" title="2、特殊二叉树"></a>2、特殊二叉树</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p>
<p><strong>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</strong></p>
<p>我来举一个典型的例子如题：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903-20230310123444151.png" alt="img"></p>
<p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p>
<p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p>
<h3 id="2673-使二叉树所有路径值相等的最小代价"><a href="#2673-使二叉树所有路径值相等的最小代价" class="headerlink" title="2673. 使二叉树所有路径值相等的最小代价"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/">2673. 使二叉树所有路径值相等的最小代价</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minIncrements</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">        ans += Math.abs(cost[i] - cost[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 叶节点 i 和 i+1 的双亲节点下标为 i/2（整数除法）</span></span><br><span class="line">        cost[i / <span class="number">2</span>] += Math.max(cost[i], cost[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>一棵度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><h3 id="二叉搜索树-1"><a href="#二叉搜索树-1" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。意味着中序遍历是一个顺序递增数组</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p>下面这两棵树都是搜索树</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img"></p>
<h4 id="数组构建二叉搜索树"><a href="#数组构建二叉搜索树" class="headerlink" title="数组构建二叉搜索树"></a>数组构建二叉搜索树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rightIndex - leftIndex &lt; <span class="number">0</span>) &#123;<span class="comment">// 没有元素了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxVal=(leftIndex+rightIndex)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxVal]);</span><br><span class="line">    <span class="comment">// 根据maxIndex划分左右子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree2(nums, leftIndex, (leftIndex+rightIndex)/<span class="number">2</span>-<span class="number">1</span>);</span><br><span class="line">    root.right = constructMaximumBinaryTree2(nums, (leftIndex+rightIndex)/<span class="number">2</span>+<span class="number">1</span>, rightIndex);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、计算节点数&#x2F;深度</p>
<p>递归的思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">leftdepth</span> <span class="operator">=</span> getdepth(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightdepth</span> <span class="operator">=</span> getdepth(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(leftdepth, rightdepth); <span class="comment">// 中</span></span><br></pre></td></tr></table></figure>

<p>Ps:在选择边界时尽量使用统一选择要么都左闭右开要么右闭左开</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//从中序和后序构造二叉树</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                            postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                            postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//**从前序与中序遍历序列构造二叉树**</span></span><br><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd, <span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(preorder[preBegin]);  <span class="comment">// 找到前序遍历的第一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定前序数列的个数</span></span><br><span class="line">        root.left = findNode(preorder, preBegin + <span class="number">1</span>, preBegin + lenOfLeft + <span class="number">1</span>,</span><br><span class="line">                            inorder, inBegin, rootIndex);</span><br><span class="line">        root.right = findNode(preorder, preBegin + lenOfLeft + <span class="number">1</span>, preEnd,</span><br><span class="line">                            inorder, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>根据二叉搜索树的性质</p>
<p>如果目标节点大于当前节点值，则去右子树中删除；<br>如果目标节点小于当前节点值，则去左子树中删除；<br>如果目标节点就是当前节点，分为以下三种情况：<br>其无左子：其右子顶替其位置，删除了该节点；<br>其无右子：其左子顶替其位置，删除了该节点；<br>其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">    root.left = deleteNode(root.left,key);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">    root.right = deleteNode(root.right,key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span>)<span class="keyword">return</span> root.right;</span><br><span class="line">    <span class="keyword">if</span>(root.right==<span class="literal">null</span>)<span class="keyword">return</span> root.left;</span><br><span class="line">    TreeNode rootleft=root.left;</span><br><span class="line">    TreeNode rootright=root.right;</span><br><span class="line">    <span class="keyword">while</span> (rootright.left!=<span class="literal">null</span>)rootright=rootright.left;</span><br><span class="line">    rootright.left=rootleft;</span><br><span class="line">    root=root.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<h3 id="2476-二叉搜索树最近节点查询"><a href="#2476-二叉搜索树最近节点查询" class="headerlink" title="2476. 二叉搜索树最近节点查询"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/">2476. 二叉搜索树最近节点查询</a></h3><p>注意此处中序遍历后有个变式的二分查找,我们需要使用n和-1来判断该元素是否超出界限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">closestNodes</span><span class="params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root, arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.size();</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = arr.get(i); <span class="comment">// 转成数组，效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queries.size()); <span class="comment">// 预分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q : queries) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarysearch(a, q);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> j == n ? -<span class="number">1</span> : a[j];</span><br><span class="line">        <span class="keyword">if</span> (j == n || a[j] != q) &#123; <span class="comment">// a[j]&gt;q, a[j-1]&lt;q</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mn</span> <span class="operator">=</span> j &lt; <span class="number">0</span> ? -<span class="number">1</span> : a[j];</span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(mn,mx)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, List&lt;Integer&gt; a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, a);</span><br><span class="line">        a.add(node.val);</span><br><span class="line">        dfs(node.right, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">binarysearch</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> left=-<span class="number">1</span>,right=a.length;</span><br><span class="line">        <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[mid]&gt;=target)right=mid;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h3><p>方法三：BFS+链表<br>思路<br>既然每一层都连接成一个链表了，那么知道链表头，就能访问这一层的所有节点。</p>
<p>所以在 BFS 的时候，可以一边遍历当前层的节点，一边把下一层的节点连接起来。这样就无需存储下一层的节点了，只需要拿到下一层链表的头节点。</p>
<p>算法<br>从第一层开始（第一层只有一个 root 节点），每次循环：<br>遍历当前层的链表节点，通过节点的 left 和 right 得到下一层的节点。<br>把下一层的节点从左到右连接成一个链表。<br>拿到下一层链表的头节点，进入下一轮循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    Node dum=<span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    Node cur=root;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        dum.next=<span class="literal">null</span>;</span><br><span class="line">        Node temp=dum;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                temp.next=cur.left;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                temp.next=cur.right;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><p>前缀树就是自己生成一个树使得这个数能够存储一段String,并且在之后输入时能够判断String的前缀是否吻合或者String是否相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Tries的变量结构</span></span><br><span class="line">   <span class="keyword">private</span> Trie []children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children=<span class="keyword">new</span> <span class="title class_">Trie</span> [<span class="number">26</span>];</span><br><span class="line">         isEnd=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入时存储</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    Trie node=<span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> t=word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(node.children[t-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)&#123;</span><br><span class="line">            node.children[t-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node=node.children[t-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出对比</span></span><br><span class="line"> <span class="keyword">public</span> Trie <span class="title function_">presearch</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        Trie node=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> t=word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(node.children[t-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            node=node.children[t-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>变式 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">211. 添加与搜索单词 - 数据结构设计</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(WordDictionary dic,String word,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=word.length();</span><br><span class="line">    <span class="keyword">if</span>(length==n)<span class="keyword">return</span> dic.isEnd;</span><br><span class="line">    <span class="type">char</span> t=word.charAt(length);</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="type">WordDictionary</span> <span class="variable">item</span> <span class="operator">=</span> dic.children[t-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> item!=<span class="literal">null</span> &amp;&amp; search(item,word,length+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在遇到.代替所有字母时使用dfs进行全部的遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dic.children[j]!=<span class="literal">null</span> &amp;&amp; search(dic.children[j],word,length+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">212. 单词搜索 II</a></h3><p>遍历二维网格中的所有单元格。</p>
<p>深度优先搜索所有从当前正在遍历的单元格出发的、由相邻且不重复的单元格组成的路径。因为题目要求同一个单元格内的字母在一个单词中不能被重复使用；所以我们在深度优先搜索的过程中，每经过一个单元格，都将该单元格的字母临时修改为特殊字符（例如 #），以避免再次经过该单元格。</p>
<p>如果当前路径是 words\textit{words}words 中的单词，则将其添加到结果集中。如果当前路径是 wordswordswords 中任意一个单词的前缀，则继续搜索；反之，如果当前路径不是 wordswordswords 中任意一个单词的前缀，则剪枝。我们可以将 words\textit{words}words 中的所有字符串先添加到前缀树中，而后用 O(∣S∣)O(|S|)O(∣S∣) 的时间复杂度查询当前路径是否为 words\textit{words}words 中任意一个单词的前缀。</p>
<p>之后再回溯，因为同一个单词可能在多个不同的路径中出现，所以我们需要使用哈希集合对结果集去重。</p>
<p>在回溯的过程中，我们不需要每一步都判断完整的当前路径是否是 words中任意一个单词的前缀；而是可以记录下路径中每个单元格所对应的前缀树结点，每次只需要判断新增单元格的字母是否是上一个单元格对应前缀树结点的子结点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//循环测试每个字母开头判断是否存在单词</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">Trie2</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie2</span>();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                dfs(board, trie, i, j, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//深度搜索寻找到单词</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, Trie2 now, <span class="type">int</span> i1, <span class="type">int</span> j1, Set&lt;String&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!now.children.containsKey(board[i1][j1])) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> board[i1][j1];</span><br><span class="line">        <span class="type">Trie2</span> <span class="variable">nxt</span> <span class="operator">=</span> now.children.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(nxt.word)) &#123;</span><br><span class="line">            ans.add(nxt.word);</span><br><span class="line">            nxt.word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//标记已经遍历的位置为# 然后回溯为了findwords的下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (!nxt.children.isEmpty()) &#123;</span><br><span class="line">            board[i1][j1] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1 + dir[<span class="number">0</span>], j2 = j1 + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span> &amp;&amp; i2 &lt; board.length &amp;&amp; j2 &gt;= <span class="number">0</span> &amp;&amp; j2 &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                    dfs(board, nxt, i2, j2, ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            board[i1][j1] = ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nxt.children.isEmpty()) &#123;</span><br><span class="line">            now.children.remove(ch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造字典树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie2</span> &#123;</span><br><span class="line">    String word;</span><br><span class="line">    Map&lt;Character, Trie2&gt; children;</span><br><span class="line">    <span class="type">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Trie2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie2</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!cur.children.containsKey(c)) &#123;</span><br><span class="line">                cur.children.put(c, <span class="keyword">new</span> <span class="title class_">Trie2</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.word = word;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的垂序遍历"><a href="#二叉树的垂序遍历" class="headerlink" title="二叉树的垂序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/">二叉树的垂序遍历</a></h3><p>我们需要按照优先级「“列号从小到大”，对于同列节点，“行号从小到大”，对于同列同行元素，“节点值从小到大”」进行答案构造。</p>
<p>因此我们可以对树进行遍历，遍历过程中记下这些信息 (col,row,val)(col, row, val)(col,row,val)，然后根据规则进行排序，并构造答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TreeNode ,<span class="type">int</span> []&gt; map= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        map.put(root,<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,root.val&#125;);</span><br><span class="line">        dfs(root);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.values());</span><br><span class="line">        Collections.sort(list,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]!=b[<span class="number">0</span>])<span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">1</span>]!=b[<span class="number">1</span>])<span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>]-b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size();) &#123;</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            List&lt;Integer&gt;cur=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (j&lt;list.size()&amp;&amp;list.get(j)[<span class="number">0</span>]==list.get(i)[<span class="number">0</span>])cur.add(list.get(j++)[<span class="number">2</span>]);</span><br><span class="line">            res.add(cur);</span><br><span class="line">            i=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> []node=map.get(root);</span><br><span class="line">        <span class="type">int</span> col=node[<span class="number">0</span>],row=node[<span class="number">1</span>],val=node[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(root.left, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;col - <span class="number">1</span>, row + <span class="number">1</span>, root.left.val&#125;);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(root.right, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;col + <span class="number">1</span>, row + <span class="number">1</span>, root.right.val&#125;);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯函数伪代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>既然是树形结构，那么我们在讲解<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归 (opens new window)</a>的时候，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png"></p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p>
<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li><p>组合问题：N个数里面按一定规则找出k个数的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineHelper</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切割问题：一个字符串按一定规则有几种切割方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//如果是回文子串，则记录</span></span><br><span class="line">           <span class="keyword">if</span> (isPalindrome(s, startIndex, i)) &#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);</span><br><span class="line">               deque.addLast(str);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//起始位置后移，保证不重复</span></span><br><span class="line">           backTracking(s, i + <span class="number">1</span>);</span><br><span class="line">           deque.removeLast();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子集问题：一个N个数的集合里有多少符合条件的子集</p>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>
<p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>
<p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subsetsHelper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">       result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));<span class="comment">//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。</span></span><br><span class="line">       <span class="keyword">if</span> (startIndex &gt;= nums.length)&#123; <span class="comment">//终止条件可不加</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++)&#123;</span><br><span class="line">           path.add(nums[i]);</span><br><span class="line">           subsetsHelper(nums, i + <span class="number">1</span>);</span><br><span class="line">           path.removeLast();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>排列问题：N个数按一定规则全排列，有几种排列方式</p>
<p>这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.切割问题 (opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题 (opens new window)</a>最大的不同就是for循环里不用startIndex了。</p>
<p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p>
<p>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">            <span class="comment">// 如果同⼀树层nums[i - 1]使⽤过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;              </span><br><span class="line">            <span class="comment">//如果同⼀树⽀nums[i]没使⽤过开始处理</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;<span class="comment">//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用</span></span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTrack(nums, used);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复</span></span><br><span class="line">                used[i] = <span class="literal">false</span>;<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h3><p>思路主要掌握二叉搜索树的中序遍历过程以及双向链表的创建方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node pre,head;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    dfs2(root);</span><br><span class="line">    pre.right=head;</span><br><span class="line">    head.left=pre;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs2</span><span class="params">(Node cur)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    dfs2(cur.left);</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">null</span>) pre.right = cur;</span><br><span class="line">    <span class="keyword">else</span> head = cur;</span><br><span class="line">    cur.left=pre;</span><br><span class="line">    pre=cur;</span><br><span class="line">    dfs2(cur.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><font color="red"><strong>二叉树遍历从下到上依靠的就是回溯算法</strong></font></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==p||root==q||root==<span class="literal">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left=lowestCommonAncestor2(root.left,p,q);</span><br><span class="line">    TreeNode right=lowestCommonAncestor2(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;        </span><br></pre></td></tr></table></figure>

<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><strong>这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了</strong>。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303-20230310122134167.jpg" alt="51.N皇后" style="zoom: 50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; result4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">        Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    queensHelper(chessboard, <span class="number">0</span>,n );</span><br><span class="line">    <span class="keyword">return</span> result4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queensHelper</span><span class="params">(<span class="type">char</span>[][]chessboard,<span class="type">int</span> row,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">        result4.add(Array2List(chessboard));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isValid(row,col,n,chessboard))&#123;</span><br><span class="line">            chessboard[row][col]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            queensHelper(chessboard,row+<span class="number">1</span>,n);</span><br><span class="line">            chessboard[row][col]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List <span class="title function_">Array2List</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>[] c : chessboard) &#123;</span><br><span class="line">        list.add(String.copyValueOf(c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">    <span class="comment">//row</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chessboard[i][col]==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//45o</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=row-<span class="number">1</span>, j=col-<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//135o</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=row-<span class="number">1</span>, j=col+<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;=n-<span class="number">1</span>; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h2><p><strong><font color="yellow">dfs是由底下遍历到上层,而bfs是由上层依次遍历到底层</font></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nLeft</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nRight</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> nLeft &gt; nRight ? nLeft + <span class="number">1</span> : nRight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和，递归，回溯"><a href="#前缀和，递归，回溯" class="headerlink" title="前缀和，递归，回溯"></a>前缀和，递归，回溯</h2><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>在同一个路径之下（可以理解成二叉树从root节点出发，到叶子节点的某一条路径），如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数</span></span><br><span class="line">    Map&lt;Long, Integer&gt; prefixSumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 前缀和为0的一条路径</span></span><br><span class="line">    prefixSumCount.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 前缀和的递归回溯思路</span></span><br><span class="line">    <span class="keyword">return</span> recursionPathSum(root, prefixSumCount, sum, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recursionPathSum</span><span class="params">(TreeNode node, Map&lt;Long, Integer&gt; prefixSumCount, <span class="type">int</span> target, <span class="type">long</span> currSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.本层要做的事情</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前路径上的和</span></span><br><span class="line">        currSum += node.val;-</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---核心代码</span></span><br><span class="line">        <span class="comment">// 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径</span></span><br><span class="line">        <span class="comment">// 当前节点-&gt;root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span></span><br><span class="line">        <span class="comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span></span><br><span class="line">        res += prefixSumCount.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 更新路径上当前节点前缀和的个数</span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//---核心代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.进入下一层</span></span><br><span class="line">        res += recursionPathSum(node.left, prefixSumCount, target, currSum);</span><br><span class="line">        res += recursionPathSum(node.right, prefixSumCount, target, currSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>例如，考虑如下二叉树。</p>
<p>   -10<br>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>叶节点 999、151515、777 的最大贡献值分别为 999、151515、777。</p>
<p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 202020 的最大贡献值等于 20+max⁡(15,7)&#x3D;3520+\max(15,7)&#x3D;3520+max(15,7)&#x3D;35，节点 −10-10−10 的最大贡献值等于 −10+max⁡(9,35)&#x3D;25-10+\max(9,35)&#x3D;25−10+max(9,35)&#x3D;25。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxsum=Integer.MIN_VALUE;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftgain=Math.max(dfs(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> rightgain=Math.max(dfs(root.right),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum=root.val+leftgain+rightgain;</span><br><span class="line">        maxsum=Math.max(sum,maxsum);</span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftgain, rightgain);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2602-使数组元素全部相等的最少操作次数"><a href="#2602-使数组元素全部相等的最少操作次数" class="headerlink" title="2602. 使数组元素全部相等的最少操作次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/">2602. 使数组元素全部相等的最少操作次数</a></h3><p>此题关键点在于排序后如何找到分割点，这样的话对于小于的我们用long left&#x3D;(long) q * j - sum[j];大于的我们用long right&#x3D;sum[n]-sum[j]-(long) q * (n - j);</p>
<p>通过前缀和我来求得一系列的元素总和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Long&gt; <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] queries)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">long</span>[] sum = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>]; <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    List&lt;Long&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Long&gt;(queries.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> q:queries) &#123;</span><br><span class="line">        <span class="type">int</span> j=search(nums,q);</span><br><span class="line">        <span class="type">long</span> left=(<span class="type">long</span>) q * j - sum[j];</span><br><span class="line">        <span class="type">long</span> right=sum[n]-sum[j]-(<span class="type">long</span>) q * (n - j);</span><br><span class="line">        ans.add(left+right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> nums[],<span class="type">int</span> tar)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;tar)left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-括号生成301-删除无效的括号"><a href="#22-括号生成301-删除无效的括号" class="headerlink" title="22. 括号生成301. 删除无效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></h3><p>这两题思路相似都是处理括号有效的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt;result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String cur,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">            result.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(cur+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(cur+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lremove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rremove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                lremove++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lremove == <span class="number">0</span>) &#123;</span><br><span class="line">                    rremove++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lremove--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(s, <span class="number">0</span>, lremove, rremove);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> lremove, <span class="type">int</span> rremove)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lremove == <span class="number">0</span> &amp;&amp; rremove == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(str)) &#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != start &amp;&amp; str.charAt(i) == str.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果剩余的字符无法满足去掉的数量要求，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (lremove + rremove &gt; str.length() - i) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试去掉一个左括号</span></span><br><span class="line">            <span class="keyword">if</span> (lremove &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                helper(str.substring(<span class="number">0</span>, i) + str.substring(i + <span class="number">1</span>), i, lremove - <span class="number">1</span>, rremove);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试去掉一个右括号</span></span><br><span class="line">            <span class="keyword">if</span> (rremove &gt; <span class="number">0</span> &amp;&amp; str.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                helper(str.substring(<span class="number">0</span>, i) + str.substring(i + <span class="number">1</span>), i, lremove, rremove - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><p><img src="https://pic.leetcode-cn.com/1614650837-SAIiWg-1.png" alt="1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] sum;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = n == <span class="number">0</span> ? <span class="number">0</span> : matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="comment">// 与「一维前缀和」一样，前缀和数组下标从 1 开始，因此设定矩阵形状为 [n + 1][m + 1]（模板部分）</span></span><br><span class="line">       sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">       <span class="comment">// 预处理除前缀和数组（模板部分）</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">               sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> &#123;</span><br><span class="line">       <span class="comment">// 求某一段区域和 [i, j] 的模板是 sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];（模板部分）</span></span><br><span class="line">       <span class="comment">// 但由于我们源数组下标从 0 开始，因此要在模板的基础上进行 + 1</span></span><br><span class="line">       x1++; y1++; x2++; y2++;</span><br><span class="line">       <span class="keyword">return</span> sum[x2][y2] - sum[x1 - <span class="number">1</span>][y2] - sum[x2][y1 - <span class="number">1</span>] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><ol>
<li><h3 id="确定dp数组（dp-table）以及下标的含义"><a href="#确定dp数组（dp-table）以及下标的含义" class="headerlink" title="确定dp数组（dp table）以及下标的含义"></a>确定dp数组（dp table）以及下标的含义</h3></li>
<li><h3 id="确定递推公式"><a href="#确定递推公式" class="headerlink" title="确定递推公式"></a>确定递推公式</h3></li>
<li><h3 id="dp数组如何初始化"><a href="#dp数组如何初始化" class="headerlink" title="dp数组如何初始化"></a>dp数组如何初始化</h3></li>
<li><h3 id="确定遍历顺序"><a href="#确定遍历顺序" class="headerlink" title="确定遍历顺序"></a>确定遍历顺序</h3></li>
<li><h3 id="举例推导dp数组"><a href="#举例推导dp数组" class="headerlink" title="举例推导dp数组"></a>举例推导dp数组</h3></li>
</ol>
<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h3><p>此题思想在于不以（来计算有效个数而是以)来计算有效个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = Math.max(maxans, dp[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><p>1.当 nums[i]&gt;nums[j] 时： nums[i] 可以接在nums[j] 之后（此题要求严格递增），此情况下最长上升子序列长度为dp[j]+1 ；<br>2.当 nums[i]&lt;&#x3D;nums[j] 时： nums[i] 无法接在 nums[j] 之后，此情况上升子序列不成立，跳过。<br>上述所有 1. 情况 下计算出的 dp[j]+1 的最大值，为直到 iii 的最长上升子序列长度（即 dp[i] ）。实现方式为遍历 j 时，每轮执行 dp[i]&#x3D;max(dp[i],dp[j]+1)。</p>
<p>转移方程为 dp[i] &#x3D; max(dp[i], dp[j] + 1) for j in [0, i)</p>
<p>优化方式将长度变化g寻找递增元素值， 如果num[i]&gt;g中的最后一个元素值时长度增加将其添加，如果小于则去更新g中第一个大于num[i]的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = res;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[m] &lt; num) i = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j = m;</span><br><span class="line">            &#125;</span><br><span class="line">            tails[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = res;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[m] &lt; num) i = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j = m;</span><br><span class="line">            &#125;</span><br><span class="line">            tails[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="变种题1671-得到山形数组的最少删除次数"><a href="#变种题1671-得到山形数组的最少删除次数" class="headerlink" title="变种题1671. 得到山形数组的最少删除次数"></a>变种题<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/">1671. 得到山形数组的最少删除次数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumMountainRemovals</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] pre = getLISArray(nums);</span><br><span class="line">    <span class="type">int</span>[] reversed = reverse(nums);</span><br><span class="line">    <span class="type">int</span>[] suf = getLISArray(reversed);</span><br><span class="line">    suf = reverse(suf);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i] &gt; <span class="number">1</span> &amp;&amp; suf[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, pre[i] + suf[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n - ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLISArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] reversed = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            reversed[i] = nums[n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reversed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h3><img src="https://pic.leetcode-cn.com/77d1aa6a444743d3c8606ac951cd7fc38faf68a62064fd2639df517cd666a4d0-Picture1.png" alt="Picture1.png" style="zoom:50%;">

<p>第一种情况：这个子数组不是环状的，就是说首尾不相连。<br>第二种情况：这个子数组一部分在首部，一部分在尾部，我们可以将这第二种情况转换成第一种情况</p>
<p><img src="https://pic.leetcode-cn.com/1639228731-hwXkOI-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length,total=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>,maxsum=nums[<span class="number">0</span>],min=<span class="number">0</span>,minsum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            max=Math.max(max+nums[i],nums[i]);</span><br><span class="line">            maxsum=Math.max(max,maxsum);</span><br><span class="line">            min=Math.min(min+nums[i],nums[i]);</span><br><span class="line">            maxsum=Math.min(min,minsum);</span><br><span class="line">            total+=nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum &gt; <span class="number">0</span> ? Math.max(maxsum, total - minsum) : maxsum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1696-跳跃游戏-VI"><a href="#1696-跳跃游戏-VI" class="headerlink" title="1696. 跳跃游戏 VI"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-vi/">1696. 跳跃游戏 VI</a></h3><p>动态规划加滑动窗口，使用一个queue来负责记录最大的取值的位置 dp数组为走到当前位置能获取的最大分数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxResult</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    queue.offerLast(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peekFirst() &lt; i - k) &#123;</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = dp[queue.peekFirst()] + nums[i];</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; dp[queue.peekLast()] &lt;= dp[i]) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offerLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png" alt="416.分割等和子集1" style="zoom: 67%;">

<p>给定一个数组，数组中含有重复的元素，给定两个数字num1，num2，求这两个数字在数组中出现的位置的最小距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr==<span class="literal">null</span>||arr.length&lt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;参数不合格!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> lastPos1=-<span class="number">1</span>; <span class="comment">//上次遍历到num1的位置</span></span><br><span class="line">		<span class="type">int</span> lastPos2=-<span class="number">1</span>; <span class="comment">//上次遍历到num1的位置</span></span><br><span class="line">		<span class="type">int</span> minDis=Integer.MAX_VALUE;  <span class="comment">//num1,num2的最小距离</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]==num1)</span><br><span class="line">			&#123;</span><br><span class="line">				lastPos1=i;</span><br><span class="line">				<span class="keyword">if</span>(lastPos2&gt;=<span class="number">0</span>)</span><br><span class="line">					minDis=Math.min(minDis, lastPos1-lastPos2);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]==num2)</span><br><span class="line">			&#123;</span><br><span class="line">				lastPos2=i;</span><br><span class="line">				<span class="keyword">if</span>(lastPos1&gt;=<span class="number">0</span>)</span><br><span class="line">					minDis=Math.min(minDis, lastPos2-lastPos1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minDis;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="01背包理论基础"><a href="#01背包理论基础" class="headerlink" title="01背包理论基础"></a>01背包理论基础</h2><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png" alt="动态规划-背包问题2"></p>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程 dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]); 可以看出i 是由 i-<span class="number">1</span> 推导出来，那么i为<span class="number">0</span>的时候就一定要初始化。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png" alt="动态规划-背包问题5"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先遍历背包再遍历物品</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png" alt="动态规划-背包问题6"></p>
<h3 id="一维dp数组（滚动数组）"><a href="#一维dp数组（滚动数组）" class="headerlink" title="一维dp数组（滚动数组）"></a>一维dp数组（滚动数组）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<h2 id="完全背包理论基础"><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h2><p><strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>很少出现</p>
<h3 id="337-打家劫舍-II"><a href="#337-打家劫舍-II" class="headerlink" title="337. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">337. 打家劫舍 II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> robRange(nums, <span class="number">0</span>, nums.length- <span class="number">2</span>); <span class="comment">// 情况二</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> robRange(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>); <span class="comment">// 情况三</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robRange</span><span class="params">(<span class="type">int</span> []nums,<span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end == begin) <span class="keyword">return</span> nums[begin];</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">    dp[begin] = nums[begin];</span><br><span class="line">    dp[begin + <span class="number">1</span>] = Math.max(nums[begin], nums[begin + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=begin+<span class="number">2</span>;i&lt;=end;i++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h3><p>此题破题在于对于负数的处理，选择mindp和maxdp两个来存储最大值、最小值，这样在遇到负数时交换两个的值就可以</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p>
<p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String word=s.substring(j,i);</span><br><span class="line"><span class="keyword">if</span>(set.contains(word)&amp;&amp;dp[j])&#123;</span><br><span class="line">    dp[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></p>
<p>此类型题目一般会给出target 值以及物品值，使用物品值与target匹配在计算dp数组时下标计算则是按照他们target与物品值的差值来计算下标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> dp[]=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;=nums[i] ; j--) &#123;</span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[target] == target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//494. 目标和 此题主要思路与分割等和子集相同先将(sum+target)/2得到我们要分割的子集 只是这个是求满足和的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> ( target &lt; <span class="number">0</span> &amp;&amp; sum &lt; -target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">0</span>) size = -size;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> size; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt; dp.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]]!=max)&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="1143-最长公共子序列-718-最长重复子数组-115-不同的子序列"><a href="#1143-最长公共子序列-718-最长重复子数组-115-不同的子序列" class="headerlink" title="1143. 最长公共子序列,718. 最长重复子数组 115. 不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>,<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h3><p>2维的dp数组使用dp[i][j]分别代表第一个数组和第二个数组的长度 他们在创建时都创建为dp[i+1][j+1]这样才能读取前一个的字符位置计算下一个字符位置，使得字符串长度从1开始而不是从0开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长重复数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.size(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最长公共子序列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=text1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=text2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 115. 不同的子序列</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">sChar</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">tChar</span> <span class="operator">=</span> t.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (sChar == tChar) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h3 id="518-零钱兑换-II，377-组合总和-Ⅳ"><a href="#518-零钱兑换-II，377-组合总和-Ⅳ" class="headerlink" title="518. 零钱兑换 II，377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>这两个就是明显的组合数和排列数的计算，求装满背包有几种方法，递推公式一般都是dp[i] +&#x3D; dp[i - nums[j]];</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求组合数先遍历物品容量再遍历背包重量 零钱兑换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求排列数先遍历背包重量在遍历物品重量</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= nums[j]) &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="买卖股票类型题目"><a href="#买卖股票类型题目" class="headerlink" title="买卖股票类型题目"></a>买卖股票类型题目</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></p>
<p>对于第一二两个题递推公式为：</p>
<p>这里重申一下dp数组的含义：</p>
<ul>
<li><pre><code class="java">- dp[i][0]表示第i天持有股票所得现金。
- dp[i][1] 表示第i天不持有股票所得最多现金
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第三题</span><br><span class="line"></span><br><span class="line">1. 确定dp数组以及下标的含义</span><br><span class="line"></span><br><span class="line">一天一共就有五个状态，</span><br><span class="line"></span><br><span class="line">1. 没有操作 （其实我们也可以不设置这个状态）</span><br><span class="line">2. 第一次持有股票</span><br><span class="line">3. 第一次不持有股票</span><br><span class="line">4. 第二次持有股票</span><br><span class="line">5. 第二次不持有股票</span><br><span class="line"></span><br><span class="line">dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">确定递推公式</span><br><span class="line">达到dp[i][1]状态，有两个具体操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]</span><br><span class="line">操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</span><br><span class="line">那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</span><br><span class="line"></span><br><span class="line">一定是选最大的，所以 dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);</span><br><span class="line"></span><br><span class="line">同理dp[i][2]也有两个操作：</span><br><span class="line"></span><br><span class="line">操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</span><br><span class="line">操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</span><br><span class="line">所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</span><br><span class="line"></span><br><span class="line">同理可推出剩下状态部分：</span><br><span class="line"></span><br><span class="line">dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span><br><span class="line"></span><br><span class="line">dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span><br><span class="line"></span><br><span class="line"> 			dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</span><br><span class="line">            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</span><br><span class="line">            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span><br><span class="line">            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span><br></pre></td></tr></table></figure>

第四题状态更多的第三题自然就是题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。**偶数就是卖出，奇数就是买入**

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k*<span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k*<span class="number">2</span> - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">               dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">               dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>含冷冻期此题</p>
<ul>
<li><p>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</p>
</li>
<li><p>不持有股票状态，这里就有两种卖出股票状态</p>
<ul>
<li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li>
<li>状态三：今天卖出股票</li>
</ul>
</li>
<li><p>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</p>
</li>
<li></li>
<li><pre><code class="cpp">for (int i = 1; i &lt; n; i++) &#123;
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">手续费题思路和第二题相似只需要在执行时减去手续费</span><br><span class="line"></span><br><span class="line">### 特殊思想dp转换</span><br><span class="line"></span><br><span class="line">#### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)</span><br><span class="line"></span><br><span class="line">关键点在于理解转换三个状态其中，`dp[i-1][j-1]` 表示替换操作，`dp[i-1][j]` 表示删除操作，`dp[i][j-1]` 表示插入操作。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> // 第一行</span><br><span class="line">        for (int j = 1; j &lt;= n2; j++) dp[0][j] = dp[0][j - 1] + 1;</span><br><span class="line">        // 第一列</span><br><span class="line">        for (int i = 1; i &lt;= n1; i++) dp[i][0] = dp[i - 1][0] + 1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= n1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n2; j++) &#123;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                else dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="337-打家劫舍-III-树形dp的应用"><a href="#337-打家劫舍-III-树形dp的应用" class="headerlink" title="337.打家劫舍 III 树形dp的应用"></a>337.打家劫舍 III 树形dp的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = robAction1(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] robAction1(TreeNode root) &#123;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] left = robAction1(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = robAction1(root.right);</span><br><span class="line"></span><br><span class="line">        res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        res[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2008-出租车的最大盈利"><a href="#2008-出租车的最大盈利" class="headerlink" title="2008. 出租车的最大盈利"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a></h3><p>状态方程很明显</p>
<p>dp<sub>i+1</sub>&#x3D;max(dp<sub>i</sub>,dp<sub>j</sub>+end<sub>i</sub>−star<sub>i</sub>+tip<sub>i</sub>)</p>
<p>基础思想在于及时更新前面地区所取得的费用也就是没此在计算前更新dp[rides[1]]之前的数据，二分优化：找到在第 i 个乘客上车地点之前，最后一个下车地点不大于 start<sub>i</sub> 的乘客，记为 j. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxTaxiEarnings</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] rides)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(rides, (a,b) -&gt; a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ride:rides) &#123;</span><br><span class="line">           <span class="keyword">for</span> (; end &lt;= ride[<span class="number">1</span>]; end++) &#123;</span><br><span class="line">               dp[end] = Math.max(dp[end], dp[end-<span class="number">1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">           dp[ride[<span class="number">1</span>]] = Math.max(dp[ride[<span class="number">1</span>]], dp[ride[<span class="number">0</span>]] + ride[<span class="number">2</span>] + ride[<span class="number">1</span>] - ride[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//二分法优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxTaxiEarnings</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] rides)</span> &#123;</span><br><span class="line">        Arrays.sort(rides, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> rides.length;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarySearch1(rides, i, rides[i][<span class="number">0</span>]);</span><br><span class="line">            dp[i + <span class="number">1</span>] = Math.max(dp[i], dp[j] + rides[i][<span class="number">1</span>] - rides[i][<span class="number">0</span>] + rides[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[][] rides, <span class="type">int</span> right, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> mid=low+(right-low)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(rides[mid][<span class="number">1</span>]&gt;target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1235-规划兼职工作"><a href="#1235-规划兼职工作" class="headerlink" title="1235. 规划兼职工作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/">1235. 规划兼职工作</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">    <span class="type">int</span>[][] jobs = <span class="keyword">new</span> <span class="title class_">int</span>[n][];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        jobs[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class="line">    Arrays.sort(jobs, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]); <span class="comment">// 按照结束时间排序</span></span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Search(jobs, i, jobs[i][<span class="number">0</span>]);</span><br><span class="line">        f[i + <span class="number">1</span>] = Math.max(f[i], f[j + <span class="number">1</span>] + jobs[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 endTime &lt;= upper 的最大下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Search</span><span class="params">(<span class="type">int</span>[][] jobs, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (jobs[mid][<span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2312-卖木头块"><a href="#2312-卖木头块" class="headerlink" title="2312. 卖木头块"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/selling-pieces-of-wood/">2312. 卖木头块</a></h3><p>此题意义就是将图块分割为不同大小的块，计算总价值最大的情况，找到dp公式分三种情况，一直直接卖，一种垂直切割后卖，一种水平切割后卖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] pr = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p[] : prices) pr[p[<span class="number">0</span>]][p[<span class="number">1</span>]] = p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[][] f = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;=m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=n; j++) &#123;</span><br><span class="line">            f[i][j]=pr[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; j; k++) f[i][j] = Math.max(f[i][j], f[i][k] + f[i][j - k]); <span class="comment">// 垂直切割</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; i; k++) f[i][j] = Math.max(f[i][j], f[k][j] + f[i - k][j]); <span class="comment">// 水平切割</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h3><p>此类面积dp都是以i，j代表矩形或者正方形的右下顶点，dp[i] [j]就可以靠左边上方左上方得到</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h4 id="514-自由之路"><a href="#514-自由之路" class="headerlink" title="514. 自由之路"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/freedom-trail/">514. 自由之路</a></h4><p><img src="/2023/09/19/leecode-sum-up/514.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRotateSteps</span><span class="params">(String ring, String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r=ring.length(),k=key.length();</span><br><span class="line">        List&lt;Integer&gt;pos[]=<span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            pos[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            pos[ring.charAt(i)-<span class="string">&#x27;a&#x27;</span>].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> dp[][]=<span class="keyword">new</span> <span class="title class_">int</span>[k][r];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;k ; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0x3f3f3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : pos[key.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.min(i, r - i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j :pos[key.charAt(i)-<span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l:pos[key.charAt(i-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i][j],dp[i-<span class="number">1</span>][l]+ Math.min(Math.abs(j - l), r - Math.abs(j - l)) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp[k - <span class="number">1</span>]).min().getAsInt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1690-石子游戏-VII"><a href="#1690-石子游戏-VII" class="headerlink" title="1690. 石子游戏 VII"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stone-game-vii/">1690. 石子游戏 VII</a></h3><p><img src="/2023/09/19/leecode-sum-up/1691(1).png" alt="image-20240203153920704"></p>
<p><img src="/2023/09/19/leecode-sum-up/1691(2).png" alt="image-20240203153948200"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">stoneGameVII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=stones.length;</span><br><span class="line">    <span class="type">int</span> sum[]=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> momo[][]=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">        sum[i]+=sum[i-<span class="number">1</span>]+stones[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=dfs(<span class="number">0</span>,n-<span class="number">1</span>,sum,momo);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end , <span class="type">int</span> sum[],<span class="type">int</span> mono[][])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin==end)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mono[begin][end]&gt;<span class="number">0</span>)<span class="keyword">return</span> mono[begin][end];</span><br><span class="line">    <span class="type">int</span> res1=sum[end+<span class="number">1</span>]-sum[begin+<span class="number">1</span>]-dfs(begin+<span class="number">1</span>,end,sum,mono);</span><br><span class="line">    <span class="type">int</span> res2=sum[end]-sum[begin]-dfs(begin,end-<span class="number">1</span>,sum,mono);</span><br><span class="line">    <span class="keyword">return</span> mono[begin][end]=Math.max(res1,res2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1312-让字符串成为回文串的最少插入次数-516-最长回文子序列"><a href="#1312-让字符串成为回文串的最少插入次数-516-最长回文子序列" class="headerlink" title="1312. 让字符串成为回文串的最少插入次数 516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/">1312. 让字符串成为回文串的最少插入次数</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h3><p>这两个题都是动态规划，使用dp[i] [j]二维数组储存代表字符串从i 到j 的的最少插入次数&#x2F;最长子序列， 然后从数组尾部开始遍历，直到遍历完整个数组为止</p>
<p><img src="https://pic.leetcode-cn.com/1662829933-UuachQ-51.svg" alt="51.svg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1312. 让字符串成为回文串的最少插入次数https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>s.length();</span><br><span class="line">    <span class="type">int</span> [][]dp=<span class="keyword">new</span> <span class="title class_">int</span> [n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 516. 最长回文子序列https://leetcode.cn/problems/longest-palindromic-subsequence/description/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][]dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h3 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h3><p>如何移除最大的数字首先是贪心算法计算左边数字和右边数字的大小,如果左边小就不移除保留,如果右边小于左边就移除左边</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/402/10.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> num.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &gt; digit) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理如果左边全部小于右边但是没有移除数字的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leadingZero</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (leadingZero &amp;&amp; digit == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leadingZero = <span class="literal">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : ret.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h3><p>这题基本思路也是使用比较将之前放入栈的元素给弹出，但是作为判断方法这个使用的是出现的总频率(int[] num &#x3D; new int[26];)来选择再来根据大小判断是否弹出,</p>
<p> boolean[] vis &#x3D; new boolean[26];则是保证每个字母都被用到,这样就可以得到最小的字母顺序组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">     <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         num[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">         <span class="keyword">if</span> (!vis[ch - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">             <span class="keyword">while</span> (sb.length() &gt; <span class="number">0</span> &amp;&amp; sb.charAt(sb.length() - <span class="number">1</span>) &gt; ch) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (num[sb.charAt(sb.length() - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     vis[sb.charAt(sb.length() - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                     sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             vis[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">             sb.append(ch);</span><br><span class="line">         &#125;</span><br><span class="line">         num[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sb.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><ul>
<li><strong>使用哨兵加单调栈的思想，分别先求每个元素左边最小元素的位置，然后再求右边的最小元素的位置</strong></li>
</ul>
<p>我们用一个具体的例子[6,7,5,2,4,5,9,3] 来帮助读者理解单调栈。我们需要求出每一根柱子的左侧且最近的小于其高度的柱子。初始时的栈为空。</p>
<p>我们枚举 6，因为栈为空，所以 666 左侧的柱子是「哨兵」，位置为 -1。随后我们将 6 入栈。</p>
<p>栈：[6(0)]。（这里括号内的数字表示柱子在原数组中的位置）<br>我们枚举 7，由于 6&lt;7，因此不会移除栈顶元素，所以 777 左侧的柱子是 6，位置为 0。随后我们将 7 入栈。</p>
<p>栈：[6(0), 7(1)]<br>我们枚举 5，由于 7≥5，因此移除栈顶元素 7。同样地，6≥5，再移除栈顶元素 6。此时栈为空，所以 5 左侧的柱子是「哨兵」，位置为 −1。随后我们将 5 入栈。</p>
<p>栈：[5(2)]<br>接下来的枚举过程也大同小异。我们枚举 2，移除栈顶元素 5，得到 2 左侧的柱子是「哨兵」，位置为 −1-。将 2 入栈。</p>
<p>栈：[2(3)]<br>我们枚举 4，5 和 9，都不会移除任何栈顶元素，得到它们左侧的柱子分别是 2，4 和 5，位置分别为 3，4 和 5。将它们入栈。</p>
<p>栈：[2(3), 4(4), 5(5), 9(6)]<br>我们枚举 3，依次移除栈顶元素 9，5 和 4，得到 3 左侧的柱子是 2，位置为 3。将 3入栈。</p>
<p>栈：[2(3), 3(7)]<br>这样以来，我们得到它们左侧的柱子编号分别为 [−1,0,−1,−1,3,4,5,3]。用相同的方法，我们从右向左进行遍历，也可以得到它们右侧的柱子编号分别为 [2,2,3,8,7,7,7,8]，这里我们将位置 8 看作「哨兵」。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(right, n);</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;heights[stack.peek()]&gt;=heights[i])&#123;</span><br><span class="line">            right[stack.peek()] = i;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        left[i]=(stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        res=Math.max(res,(right[i]-left[i]-<span class="number">1</span>)*heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a></h3><p>84题的变形应用，枚举矩阵高度从1开始一直到n这样就将此题转换为84题求最大矩形的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] heights = <span class="keyword">new</span> <span class="title class_">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">        <span class="comment">//遍历每一列，更新高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                heights[col] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heights[col] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用上一题的解法，更新函数</span></span><br><span class="line">        maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; heights.length) &#123;</span><br><span class="line">        <span class="comment">//栈空入栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="comment">//当前高度大于栈顶，入栈</span></span><br><span class="line">            <span class="keyword">if</span> (heights[p] &gt;= heights[top]) &#123;</span><br><span class="line">                stack.push(p);</span><br><span class="line">                p++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//保存栈顶高度</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">                <span class="comment">//左边第一个小于当前柱子的下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">leftLessMin</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                <span class="comment">//右边第一个小于当前柱子的下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">RightLessMin</span> <span class="operator">=</span> p;</span><br><span class="line">                <span class="comment">//计算面积</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (RightLessMin - leftLessMin - <span class="number">1</span>) * height;</span><br><span class="line">                maxArea = Math.max(area, maxArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//保存栈顶高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">        <span class="comment">//左边第一个小于当前柱子的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLessMin</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        <span class="comment">//右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">RightLessMin</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (RightLessMin - leftLessMin - <span class="number">1</span>) * height;</span><br><span class="line">        maxArea = Math.max(area, maxArea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2454-下一个更大元素-IV"><a href="#2454-下一个更大元素-IV" class="headerlink" title="2454. 下一个更大元素 IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-iv/">2454. 下一个更大元素 IV</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] secondGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">     <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">     Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">     List&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">     List&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[i];</span><br><span class="line">         <span class="keyword">while</span> (!stack2.isEmpty() &amp;&amp; nums[stack2.get(stack2.size() - <span class="number">1</span>)] &lt; v) &#123;</span><br><span class="line">             res[stack2.get(stack2.size() - <span class="number">1</span>)] = v;</span><br><span class="line">             stack2.remove(stack2.size() - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> stack1.size() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span> (pos &gt;= <span class="number">0</span> &amp;&amp; nums[stack1.get(pos)] &lt; v) &#123;</span><br><span class="line">             --pos;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> pos + <span class="number">1</span>; j &lt; stack1.size(); j++) &#123;</span><br><span class="line">             stack2.add(stack1.get(j));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stack1.size() - <span class="number">1</span>; j &gt;= pos + <span class="number">1</span>; j--) &#123;</span><br><span class="line">             stack1.remove(j);</span><br><span class="line">         &#125;</span><br><span class="line">         stack1.add(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2866-美丽塔-II"><a href="#2866-美丽塔-II" class="headerlink" title="2866. 美丽塔 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/beautiful-towers-ii/">2866. 美丽塔 II</a></h3><p>寻找到左边非递增的数和右边非递增的数，我们使用前后两个方向数组去存储前后缀和</p>
<p>对于左侧的非递减：将 <strong>maxHeights</strong> 依次入栈，对于第 i 个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 **maxHeights[i]**。假设此时栈顶元素为 **maxHeights[j]**，则区间[j+1,i−1] 中的元素最多只能取到 **maxHeights[i]<strong>，则</strong>prefix[i]&#x3D;prefix[j]+(i−j)×maxHeights[i]**；</p>
<p>对于右侧的非递减：将 <strong>maxHeights</strong> 依次入栈，对于第 i 个元素来说，不断从栈顶弹出元素，直到栈顶元素小于等于 **maxHeights[i]**。假设此时栈顶元素为 **maxHeights[j]**，则区间 [i+1,j−1] 中的元素最多只能取到 **maxHeights[i]**，则 <strong>suffix[i]&#x3D;suffix[j]+(j−i)×maxHeights[i]；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumSumOfHeights</span><span class="params">(List&lt;Integer&gt; maxHeights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> maxHeights.size();</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span>[] prefix = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    <span class="type">long</span>[] suffix = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">    Deque&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() &amp;&amp; maxHeights.get(i) &lt; maxHeights.get(stack1.peek())) &#123;</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) &#123;</span><br><span class="line">            prefix[i] = (<span class="type">long</span>) (i + <span class="number">1</span>) * maxHeights.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prefix[i] = prefix[stack1.peek()] + (<span class="type">long</span>) (i - stack1.peek()) * maxHeights.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty() &amp;&amp; maxHeights.get(i) &lt; maxHeights.get(stack2.peek())) &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            suffix[i] = (<span class="type">long</span>) (n - i) * maxHeights.get(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            suffix[i] = suffix[stack2.peek()] + (<span class="type">long</span>) (stack2.peek() - i) * maxHeights.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(i);</span><br><span class="line">        res = Math.max(res, prefix[i] + suffix[i] - maxHeights.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="首先要知道并查集可以解决什么问题呢？"><a href="#首先要知道并查集可以解决什么问题呢？" class="headerlink" title="首先要知道并查集可以解决什么问题呢？"></a>首先要知道并查集可以解决什么问题呢？</h2><p>主要就是集合问题，两个节点在不在一个集合，也可以将两个节点添加到一个集合中。</p>
<p>这里整理出我的并查集模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// 节点数量3 到 1000</span></span><br><span class="line"><span class="type">int</span> father[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li>
<li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li>
<li>判断两个节点是否在同一个集合，函数：same(int u, int v)，就是判断两个节点是不是同一个根节点</li>
</ol>
<h3 id="存储数据结构"><a href="#存储数据结构" class="headerlink" title="存储数据结构"></a>存储数据结构</h3><p><strong>如何表示节点与节点之间的连通性关系呢？？</strong></p>
<ul>
<li>如果<code>p</code>和<code>q</code>连通，则它们有相同的根节点</li>
</ul>
<p>用数组<code>parent[]</code>来表示这种关系</p>
<ul>
<li>如果自己就是根节点，那么<code>parent[i] = i</code>，即自己指向自己</li>
<li>如果自己不是根节点，则<code>parent[i] = root id</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UF</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = n;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 最初，每个节点均是独立的</span></span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化角度-1：平衡性优化"><a href="#优化角度-1：平衡性优化" class="headerlink" title="优化角度 1：平衡性优化"></a>优化角度 1：平衡性优化</h3><p><strong>思路：当我们每次连接两个节点的时候，不希望出现头重脚轻的情况，而希望到达一种平衡的状态</strong></p>
<p>使用额外的一个数组<code>size[]</code>记录每个连通分量中的节点数，每次均把节点数少的分量接到节点数多的分量上，如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/LFool/image-hosting@master/20220811/2250031660229403W4grn725.svg" alt="25"></p>
<p><strong>注意：只有每个连通分量的根节点的 size[] 才可以代表该连通分量中的节点数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UF</span> <span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = n;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        <span class="comment">// 最初，每个连通分量均为 1</span></span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/******** 修改部分 ********/</span></span><br><span class="line">    <span class="keyword">if</span> (size[rootP] &lt; size[rootQ]) &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        size[rootQ] += size[rootP]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">        size[rootP] += size[rootQ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/********** end **********/</span></span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化角度-2：路径压缩"><a href="#优化角度-2：路径压缩" class="headerlink" title="优化角度 2：路径压缩"></a>优化角度 2：路径压缩</h3><p><strong>思路：使树高始终保持为常数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int find(int x) &#123;</span><br><span class="line">    while (parent[x] != x) &#123;</span><br><span class="line">        // 进行路径压缩</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是用迭代实现的「路径压缩」，下面给出一种用递归实现的「路径压缩」，其效率更高！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归直接一次性把一棵树拉平了！！**(强力推荐使用这种方法！！！✨✨✨)**</p>
<p><strong>注意：</strong></p>
<ul>
<li>「路径压缩优化」比「平衡性优化」更为常用</li>
<li>当使用了「路径压缩优化」后，「平衡性优化」可以不使用</li>
<li>但是可以在某些题目中使用「平衡性优化」的思想，<strong>如 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></strong></li>
</ul>
<h3 id="完整模版"><a href="#完整模版" class="headerlink" title="完整模版"></a>完整模版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 平衡性优化</span></span><br><span class="line">        <span class="keyword">if</span> (size[rootP] &lt; size[rootQ]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">            size[rootQ] += size[rootP];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">            size[rootP] += size[rootQ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/">684. 冗余连接</a></h3><p>1.读取[1,2]：<br>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]] 当前vector[0, 1, 2, 3, 4, 5] 当前index [0, 1, 2, 3, 4, 5] 原本1-&gt;1，2-&gt;2， 由1节点出发，vector[1]&#x3D;1, 找到1所在集合的代表节点1 由2节点出发，vector[2]&#x3D;2, 找到2所在集合的代表节点2 于是，将1的代表置为2，vector[1]&#x3D;2, vector[2]&#x3D;2 对应的vector[0, 2, 2, 3, 4, 5] 对应的index [0, 1, 2, 3, 4, 5] 原集合变为下图：<img src="https://pic.leetcode-cn.com/c95f25c4df2dce2f872fdc076bc0c8168c3ad241b8bd18638da68112e013c908-image.png" alt="image.png"></p>
<p>2.读取[3, 4]<br>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]] 当前vector[0, 2, 2, 3, 4, 5] 当前index [0, 1, 2, 3, 4, 5] 同理，将3所在集合的的代表节点3的代表节点置为4 对应的vector[0, 2, 2, 4, 4, 5] 对应的index [0, 1, 2, 3, 4, 5] 集合变化如下图：<img src="https://pic.leetcode-cn.com/52d1a28110784aee9b145cd725834a51a4e9e7e87e5ec5a2ba2c83f42c44dc79-image.png" alt="image.png"></p>
<p>3.读取[3, 2]<br>读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]] 当前vector[0, 2, 2, 4, 4, 5] 当前index [0, 1, 2, 3, 4, 5] 从节点3出发，vector[3]&#x3D;4, vector[4]&#x3D;4,于是找到节点3所在集合的代表节点为4 从节点2出发，vector[2]&#x3D;2, 找到节点2所在集合的代表节点为2 于是，将4的代表置为2，vector[4]&#x3D;2, vector[2]&#x3D;2 对应的vector[0, 2, 2, 4, 2, 5] 对应的index [0, 1, 2, 3, 4, 5] 集合变化如下图：<img src="https://pic.leetcode-cn.com/0df9d3c5f9647b040b001c42c2e946975ddcc282f0c805d85e3addb126f7b695-image.png" alt="image.png"></p>
<p>4.最后读取[1,4].判断重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> edge[]=edges[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">node1</span> <span class="operator">=</span> edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(find(parent,node1)!=find(parent,node2))&#123;</span><br><span class="line">            union(parent,node1,node2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span> <span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index1, <span class="type">int</span> index2)</span>&#123;</span><br><span class="line">    parent[find(parent,index1)]=find(parent,index2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">        parent[index] = find(parent, parent[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h3><p>看到最短首先想到的就是<strong>广度优先搜索</strong></p>
<h3 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a></h3><p>标准转化为并查集题目 将两个节点的相等和不等性转换为并查集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">    <span class="type">int</span> parent[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parent.length; i++) &#123;</span><br><span class="line">        parent[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String str : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            union(parent, index1, index2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String str : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (find(parent, index1) == find(parent, index2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> parent[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x]!=x)&#123;</span><br><span class="line">        parent[x]=find(parent,parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> parent[],<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> rootX=find(parent,x);</span><br><span class="line">    <span class="type">int</span> rootY=find(parent,y);</span><br><span class="line">    parent[rootX]=rootY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a></h3><p><img src="https://pic.leetcode-cn.com/1609861645-DbxMDs-image.png" alt="image.png"></p>
<p>根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 xxx，那么 3.0⋅x&#x3D;6.0⋅4.0，得 x&#x3D;8.0。</p>
<img src="https://pic.leetcode-cn.com/1609862151-XZgKGY-image.png" alt="image.png" style="zoom: 80%;">

<p>一边查询一边修改结点指向是并查集的特色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">equationsSize</span> <span class="operator">=</span> equations.size();</span><br><span class="line">    <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(<span class="number">2</span> * equationsSize);</span><br><span class="line">    Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span> * equationsSize);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equationsSize; i++) &#123;</span><br><span class="line">        List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> equation.get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> equation.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hashMap.containsKey(var1)) &#123;</span><br><span class="line">            hashMap.put(var1, id);</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hashMap.containsKey(var2)) &#123;</span><br><span class="line">            hashMap.put(var2, id);</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">queriesSize</span> <span class="operator">=</span> queries.size();</span><br><span class="line">    <span class="type">double</span>[] res = <span class="keyword">new</span> <span class="title class_">double</span>[queriesSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> hashMap.get(var1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id2</span> <span class="operator">=</span> hashMap.get(var2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id1 == <span class="literal">null</span> || id2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            res[i] = -<span class="number">1.0d</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[i] = unionFind.isConnected(id1, id2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> parent[];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight[];</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.weight=<span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">            weight[i]=<span class="number">1.0d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> value)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span>(rootY==rootX)<span class="keyword">return</span>;</span><br><span class="line">        parent[rootX]=rootY;</span><br><span class="line">        weight[rootX]=weight[y]*value/weight[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x]!=x)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> parent[x];</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">            weight[x] *= weight[origin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> weight[x] / weight[y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1356. 根据数字二进制下 1 的数目排序  https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">cntInt</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                val = val &amp; (val - <span class="number">1</span>);</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span>[] sortByBits(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.stream(arr).boxed()</span><br><span class="line">                    .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> cntInt(o1);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> cntInt(o2);</span><br><span class="line">                            <span class="keyword">return</span> (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .mapToInt(Integer::intValue)</span><br><span class="line">                    .toArray();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是对一个 int 数组进行排序，排序规则是首先按照每个数的数字个数从小到大排序，如果数字个数相同，则按照数值大小从小到大排序。</p>
<p>具体实现是通过使用 Java 8 中的流式 API，将 int 数组转换为一个 IntStream 流，并对流中的元素进行操作。代码首先使用 <code>boxed()</code> 方法将流中的元素转换为 <code>Integer</code> 对象，然后使用 <code>sorted()</code> 方法对这些 <code>Integer</code> 对象进行排序。</p>
<p><code>sorted()</code> 方法接受一个 <code>Comparator</code> 对象作为参数，这里创建了一个匿名的 <code>Comparator</code> 对象来实现自定义的排序规则。在 <code>compare()</code> 方法中，首先分别计算了两个数字的数字个数，然后根据这些数字个数进行比较。如果数字个数相同，则按照数值大小进行比较，使用 <code>Integer.compare()</code> 方法进行比较。最后，使用 <code>mapToInt()</code> 方法将排序后的 <code>Integer</code> 对象转换为 int 类型的流，并使用 <code>toArray()</code> 方法将其转换为一个 int 数组，即返回排序后的结果。</p>
<p>需要注意的是，该实现对每个数都会计算一遍数字个数，因此在对大量数据进行排序时可能会影响性能。如果要优化性能，可以考虑使用缓存来避免重复计算数字个数。</p>
<h3 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">201. 数字范围按位与</a></h3><p>官解写的太复杂了，其实就是我们只看第一个二进制位，只存在0,1两种情况，所以如果left&lt;right，区间中必然存在left+1,那么最低位&amp;一下一定等于0了，然后不停的右移，一直移到两个相等为止，就这么简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到公共前缀</span></span><br><span class="line">    <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ++shift;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心顾名思义，就是满足每步解的最优解，这样最终解就是最优解</p>
<h3 id="55-跳跃游戏45-跳跃游戏-II"><a href="#55-跳跃游戏45-跳跃游戏-II" class="headerlink" title="55. 跳跃游戏45. 跳跃游戏 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h3><p>主要思想为计算每一步能够跳到的最大值，然后一直到最后返回true或者返回计算步数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//跳跃游戏      </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=cover;i++)&#123;</span><br><span class="line">  cover = Math.max(i + nums[i], cover);</span><br><span class="line">  <span class="keyword">if</span>(cover&gt;=nums.length-<span class="number">1</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳跃游戏 II</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    max=Math.max(max,i+nums[i]);</span><br><span class="line">    <span class="keyword">if</span>(i==end) &#123;</span><br><span class="line">        end = max;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h3><p>关键思路：要能够正常启动首先gas[i]-cost[i]&gt;&#x3D;0,其次就是能否走完最终路程需要看gas和与cost和大小如果大于那么就可以走完</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">    curSum+=gas[i]-cost[i];</span><br><span class="line">    TotalSum+=gas[i]-cost[i];</span><br><span class="line">    <span class="keyword">if</span>(curSum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        start=i+<span class="number">1</span>;</span><br><span class="line">        curSum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="846-一手顺子"><a href="#846-一手顺子" class="headerlink" title="846. 一手顺子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hand-of-straights/">846. 一手顺子</a></h3><p>注意下标和存储的结合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : hand) &#123;</span><br><span class="line">           map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">           q.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">           <span class="keyword">if</span> (map.get(t) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; groupSize; i++) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(t + i, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               map.put(t + i, cnt - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>



<h3 id="1899-合并若干三元组以形成目标三元组"><a href="#1899-合并若干三元组以形成目标三元组" class="headerlink" title="1899. 合并若干三元组以形成目标三元组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-triplets-to-form-target-triplet/">1899. 合并若干三元组以形成目标三元组</a></h3><p>关键在于满足每个三元组的要求 ，也就是每个三元组的每个位置数值满足小于等于，指定位数值相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; triplets.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(triplets[i][<span class="number">0</span>]==target[<span class="number">0</span>] &amp;&amp; triplets[i][<span class="number">1</span>]&lt;=target[<span class="number">1</span>] &amp;&amp; triplets[i][<span class="number">2</span>]&lt;=target[<span class="number">2</span>])&#123;</span><br><span class="line">              one=<span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(triplets[i][<span class="number">0</span>]&lt;=target[<span class="number">0</span>] &amp;&amp; triplets[i][<span class="number">1</span>]==target[<span class="number">1</span>] &amp;&amp; triplets[i][<span class="number">2</span>]&lt;=target[<span class="number">2</span>])&#123;</span><br><span class="line">              two=<span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(triplets[i][<span class="number">0</span>]&lt;=target[<span class="number">0</span>] &amp;&amp; triplets[i][<span class="number">1</span>]&lt;=target[<span class="number">1</span>] &amp;&amp; triplets[i][<span class="number">2</span>]==target[<span class="number">2</span>])&#123;</span><br><span class="line">              three=<span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(one &amp;&amp; three &amp;&amp; two)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h3><p>使用元素最后一次出现的位置作为最大值，找到最大的切割位置，在这个位置内的元素最大出现的位置都不会大于最大位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> last[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; partition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            end = Math.max(end, last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                partition.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2789-合并后数组中的最大元素"><a href="#2789-合并后数组中的最大元素" class="headerlink" title="2789. 合并后数组中的最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/">2789. 合并后数组中的最大元素</a></h3><p>我们从后往前倒序遍历一次数组，依次比较两个相邻的元素，如果两个相邻的元素能够合并，就将其合并。如果不能合并，就继续往前判断。因为这样的操作流程，在比较过程中，靠后的数是所有操作流程可能性中能产生的最大值，而靠前的数，是所有操作流程可能性中能产生的最小值。如果在遍历过程中，比较的结果是不能合并，那么其他任何操作流程都无法合并这两个数。如果可以合并，那我们就贪心地合并，因为这样能使接下来的比较中，靠后的数字尽可能大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxArrayValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = nums[i] &lt;= sum ? nums[i] + sum : nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/task-scheduler/">621. 任务调度器</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//统计每个任务出现的次数，找到出现次数最多的任务</span></span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.length; ++i) &#123;</span><br><span class="line">            hash[tasks[i] - <span class="string">&#x27;A&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(hash);</span><br><span class="line">        <span class="comment">//因为相同元素必须有n个冷却时间，假设A出现3次，n = 2，任务要执行完，至少形成AXX AXX A序列（X看作预占位置）</span></span><br><span class="line">        <span class="comment">//该序列长度为</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> (n+<span class="number">1</span>) *  (hash[<span class="number">25</span>] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时为了尽量利用X所预占的空间（贪心）使得整个执行序列长度尽量小，将剩余任务往X预占的空间插入</span></span><br><span class="line">        <span class="comment">//剩余的任务次数有两种情况：</span></span><br><span class="line">        <span class="comment">//1.与A出现次数相同，比如B任务最优插入结果是ABX ABX AB，中间还剩两个空位，当前序列长度+1</span></span><br><span class="line">        <span class="comment">//2.比A出现次数少，若还有X，则按序插入X位置，比如C出现两次，形成ABC ABC AB的序列</span></span><br><span class="line">        <span class="comment">//直到X预占位置还没插满，剩余元素逐个放入X位置就满足冷却时间至少为n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">24</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] == hash[<span class="number">25</span>]) ++ minLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当所有X预占的位置插满了怎么办？</span></span><br><span class="line">        <span class="comment">//在任意插满区间（这里是ABC）后面按序插入剩余元素，比如ABCD ABCD发现D之间距离至少为n+1，肯定满足冷却条件</span></span><br><span class="line">        <span class="comment">//因此，当X预占位置能插满时，最短序列长度就是task.length，不能插满则取最少预占序列长度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(minLen, tasks.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Intervals-插空类题目"><a href="#Intervals-插空类题目" class="headerlink" title="Intervals 插空类题目"></a>Intervals 插空类题目</h1><h3 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h3><p>栈的思想使用左栈和*号栈存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; leftStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">Deque&lt;Integer&gt; asteriskStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        leftStack.push(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        asteriskStack.push(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!leftStack.isEmpty()) &#123;</span><br><span class="line">            leftStack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!asteriskStack.isEmpty()) &#123;</span><br><span class="line">            asteriskStack.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!leftStack.isEmpty() &amp;&amp; !asteriskStack.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> leftStack.pop();</span><br><span class="line">    <span class="type">int</span> <span class="variable">asteriskIndex</span> <span class="operator">=</span> asteriskStack.pop();</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt; asteriskIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> leftStack.isEmpty();</span><br></pre></td></tr></table></figure>

<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">       List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line">       <span class="type">int</span> left=intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="type">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;right)&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">               left = intervals[i][<span class="number">0</span>];</span><br><span class="line">               right = intervals[i][<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               right=Math.max(intervals[i][<span class="number">1</span>],right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left, right&#125;);</span><br><span class="line">       <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h3><p>贪心思想，先将数组按照结尾排序，然后每次找到相交数组的最小结束长度，分割，这样最后总数组数减去分割出的不相交的数组个数就得到了需要删除的数组个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] o1, <span class="type">int</span>[] o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o1[<span class="number">1</span>]-o2[<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">       <span class="type">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;=right)&#123;</span><br><span class="line">               ans++;</span><br><span class="line">               right=intervals[i][<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> n-ans; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1851-包含每个查询的最小区间"><a href="#1851-包含每个查询的最小区间" class="headerlink" title="1851. 包含每个查询的最小区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-interval-to-include-each-query/">1851. 包含每个查询的最小区间</a></h3><p>此题第一眼思路是暴力求解，但是细想后发现可以先排序intervals和queries 这样遍历时就不需要每次把intervals全遍历只要遍历到intervals[i][1]&lt;queries就可以（<strong>离线算法</strong>是指在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] minInterval(<span class="type">int</span>[][] intervals, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">       Integer[] qindex = <span class="keyword">new</span> <span class="title class_">Integer</span>[queries.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">           qindex[i] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       Arrays.sort(qindex, (i, j) -&gt; queries[i] - queries[j]);</span><br><span class="line">       Arrays.sort(intervals, (i, j) -&gt; i[<span class="number">0</span>] - j[<span class="number">0</span>]);</span><br><span class="line">       PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queries.length];</span><br><span class="line">       Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> qi : qindex) &#123;</span><br><span class="line">           <span class="keyword">while</span> (i &lt; intervals.length &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= queries[qi]) &#123;</span><br><span class="line">               pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;intervals[i][<span class="number">1</span>] - intervals[i][<span class="number">0</span>] + <span class="number">1</span>, intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]&#125;);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//排序后去重虽然大于queries&gt;interval[i][0]但是也大于了interval[i][1]不在范围里面</span></span><br><span class="line">           <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek()[<span class="number">2</span>] &lt; queries[qi]) &#123;</span><br><span class="line">               pq.poll();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">               res[qi] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="会议室经典题"><a href="#会议室经典题" class="headerlink" title="会议室经典题"></a>会议室经典题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断有无会议冲突</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canAttendMeetings</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    Collections.sort(intervals, (a, b) -&gt; a.start - b.start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.get(i - <span class="number">1</span>).end &gt; intervals.get(i).start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算需要的最少的会议房间，此题是一个贪心的思想，通过将开始时间与结束时间分别排序，将开始时间大于结束时间的就可以放一组，如果不是则新开一个房间，这样最终结果就是最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> &#123;</span><br><span class="line">    <span class="comment">// Check for the base case. If there are no intervals, return 0</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer[] start = <span class="keyword">new</span> <span class="title class_">Integer</span>[intervals.size()];</span><br><span class="line">    Integer[] end = <span class="keyword">new</span> <span class="title class_">Integer</span>[intervals.size()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">        start[i] = intervals.get(i).start;</span><br><span class="line">        end[i] = intervals.get(i).end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the intervals by end time</span></span><br><span class="line">    Arrays.sort(</span><br><span class="line">            end,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a - b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// Sort the intervals by start time</span></span><br><span class="line">    Arrays.sort(</span><br><span class="line">            start,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> a - b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">startPointer</span> <span class="operator">=</span> <span class="number">0</span>, endPointer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">usedRooms</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (startPointer &lt; intervals.size()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start[startPointer] &gt;= end[endPointer]) &#123;</span><br><span class="line">            usedRooms -= <span class="number">1</span>;</span><br><span class="line">            endPointer += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usedRooms += <span class="number">1</span>;</span><br><span class="line">        startPointer += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> usedRooms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">long</span> c=<span class="number">10000007</span>;</span><br><span class="line"><span class="keyword">public</span>  <span class="type">long</span> <span class="title function_">divide</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数情况</span></span><br><span class="line">            <span class="keyword">return</span> divide((a % c) * (a % c), b / <span class="number">2</span>) % c;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//奇数情况</span></span><br><span class="line">            <span class="keyword">return</span> a % c * divide((a % c) * (a % c), (b - <span class="number">1</span>) / <span class="number">2</span>) % c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">public</span>  <span class="type">long</span> <span class="title function_">divide</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">  a %= c;</span><br><span class="line">  <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b != <span class="number">0</span>; b /= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">      res = (res * a) % c;</span><br><span class="line">    a = (a * a) % c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">quik_power</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> power)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (power &gt; <span class="number">0</span>)           <span class="comment">//指数大于0进行指数折半，底数变其平方的操作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (power &amp; <span class="number">1</span>)			<span class="comment">//指数为奇数，power &amp; 1这相当于power % 2 == 1</span></span><br><span class="line">			result *= base;     <span class="comment">//分离出当前项并累乘后保存</span></span><br><span class="line">		power &gt;&gt;= <span class="number">1</span>;			<span class="comment">//指数折半,power &gt;&gt;= 1这相当于power /= 2;</span></span><br><span class="line">		base *= base;           <span class="comment">//底数变其平方</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;              <span class="comment">//返回最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p><img src="/2023/09/19/leecode-sum-up/1137.png" alt="image-20240524001117376"></p>
<h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span>[][] mul(<span class="type">int</span>[][] a, <span class="type">int</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span>[][] c = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j] + a[i][<span class="number">2</span>] * b[<span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span>[][] mat = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) != <span class="number">0</span>) ans = mul(ans, mat);</span><br><span class="line">            mat = mul(mat, mat);</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>][<span class="number">0</span>] + ans[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="摩尔投票法：求的是绝对众数"><a href="#摩尔投票法：求的是绝对众数" class="headerlink" title="摩尔投票法：求的是绝对众数"></a>摩尔投票法：求的是绝对众数</h5><p><img src="/2023/09/19/leecode-sum-up/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20230430151444159.png" alt="image-20230430151444159"></p>
<p><img src="https://pic.leetcode-cn.com/1603612327-bOQxzq-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,vote=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vote==<span class="number">0</span>)x=nums[i];</span><br><span class="line">        vote+=nums[i]==x?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">majority</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, cnt = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cnt = nums[i] == majority ? cnt + <span class="number">1</span> : cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            majority = nums[i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : nums)</span><br><span class="line">        <span class="keyword">if</span> (val == majority)</span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt; nums.length / <span class="number">2</span> ? majority : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/roman-to-integer/">13. 罗马数字转整数</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//破题点当前位置的元素比下个位置的元素小，就减去当前值，否则加上当前值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">preNum</span> <span class="operator">=</span> getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length(); i ++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getValue(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span>(preNum &lt; num) &#123;</span><br><span class="line">            sum -= preNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += preNum;</span><br><span class="line">        &#125;</span><br><span class="line">        preNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += preNum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="365-水壶问题"><a href="#365-水壶问题" class="headerlink" title="365. 水壶问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/water-and-jug-problem/">365. 水壶问题</a></h3><p><a href="https://leetcode.cn/link/?target=https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&fromid=5185441">贝祖定理</a>寻找最大公约数如果target能整除则可以</p>
<h3 id="2575-找出字符串的可整除数组"><a href="#2575-找出字符串的可整除数组" class="headerlink" title="2575. 找出字符串的可整除数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">2575. 找出字符串的可整除数组</a></h3><p><img src="/2023/09/19/leecode-sum-up/2575.png" alt="image-20240306191903172"></p>
<p>这样可以化解爆int的情况 提前取模这样余数就不会超int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] divisibilityArray(String word, <span class="type">int</span> m) &#123;</span><br><span class="line">    <span class="type">int</span> res[]=<span class="keyword">new</span> <span class="title class_">int</span>[word.length()];</span><br><span class="line">    <span class="type">long</span> cur=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> c=word.charAt(i);</span><br><span class="line">        cur=cur*<span class="number">10</span>+Integer.valueOf(i);</span><br><span class="line">        System.out.println(cur);</span><br><span class="line">        <span class="keyword">if</span>(cur%m==<span class="number">0</span>)res[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> res[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>公式!!! 卡塔兰数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></p>
<p><em><strong>概念一</strong></em></p>
<p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数<br>那么：<br>(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数<br>即实现了 rand_XY()</p>
<p><em><strong>概念二</strong></em></p>
<p>只要<code>rand_N()</code>中N是2的倍数，就都可以用来实现<code>rand2()</code>，反之，若N不是2的倍数，则产生的结果不是等概率的</p>
<p>ok，现在回到本题中。已知rand7()，要求通过rand7()来实现rand10()。</p>
<p>有了前面的分析，要实现rand10()，就需要先实现rand_N()，并且保证N大于10且是10的倍数。这样再通过rand_N() % 10 + 1 就可以得到[1,10]范围的随机数了。</p>
<p>]但是这样实现的N不是10的倍数啊！这该怎么处理？这里就涉及到了“拒绝采样”的知识了，也就是说，如果某个采样结果不在要求的范围内，则丢弃它。基于上面的这些分析，再回头看下面的代码，想必是不难理解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7(); <span class="comment">// 等概率生成[1,49]范围的随机数</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样，并返回[1,10]范围的随机数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据part 1的分析，我们已经知道(rand7() - 1) * 7 + rand7() 等概率生成[1,49]范围的随机数。而由于我们需要的是10的倍数，因此，不得不舍弃掉[41, 49]这9个数。优化的点就始于——我们能否利用这些范围外的数字，以减少丢弃的值，提高命中率总而提高随机数生成效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> rand7();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 49</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">40</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>; <span class="comment">// 拒绝采样</span></span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">40</span>; <span class="comment">// rand 9</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 63</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">60</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            a = num - <span class="number">60</span>; <span class="comment">// rand 3</span></span><br><span class="line">            b = rand7();</span><br><span class="line">            num = (a-<span class="number">1</span>)*<span class="number">7</span> + b; <span class="comment">// rand 21</span></span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">20</span>) <span class="keyword">return</span> num % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h3><img src="/2023/09/19/leecode-sum-up/Users\王刚\AppData\Roaming\Typora\typora-user-images\image-20240729084058459.png" alt="image-20240729084058459" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> getCnt(ans, n);</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) &#123;</span><br><span class="line">                k -= cnt; ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k--; ans *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCnt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> String.valueOf(x), b = String.valueOf(limit);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length(), m = b.length(), k = m - n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, u = Integer.parseInt(b.substring(<span class="number">0</span>, n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) ans += Math.pow(<span class="number">10</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (u &gt; x) ans += Math.pow(<span class="number">10</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (u == x) ans += limit - x * Math.pow(<span class="number">10</span>, k) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串转换整数-atoi-7-整数反转"><a href="#8-字符串转换整数-atoi-7-整数反转" class="headerlink" title="8. 字符串转换整数 (atoi) 7. 整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a> <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//每次取末尾数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否 大于 最大32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;<span class="number">214748364</span> || (res==<span class="number">214748364</span> &amp;&amp; tmp&gt;<span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否 小于 最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&lt;-<span class="number">214748364</span> || (res==-<span class="number">214748364</span> &amp;&amp; tmp&lt;-<span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//8</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>, up=Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,sign =<span class="number">1</span>,len=s.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++i==len)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;-&#x27;</span>)sign=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;-&#x27;</span>||s.charAt(i)==<span class="string">&#x27;+&#x27;</span>)i++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j) &lt; <span class="string">&#x27;0&#x27;</span> || s.charAt(j) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; up || res == up &amp;&amp; s.charAt(j) &gt; <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            res = res * <span class="number">10</span> + (s.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign*res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>200、岛屿数量 本质是图的连通性的问题 寻找有多少个连通图</p>
<p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。</p>
<p><img src="https://pic.leetcode-cn.com/63f5803e9452ccecf92fa64f54c887ed0e4e4c3434b9fb246bf2b410e4424555.jpg" alt="网格结构中四个相邻的格子"></p>
<p>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</p>
<p><img src="https://pic.leetcode-cn.com/5a91ec351bcbe8e631e7e3e44e062794d6e53af95f6a5c778de369365b9d994e.jpg" alt="网格 DFS 的 base case"></p>
<p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root &#x3D;&#x3D; null 再返回。</p>
<p>这样，我们得到了网格 DFS 遍历的框架代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><p>破题点在于沿边遍历这样可以分开寻找到能流进Atlantic 和Pacific的岛屿然后求交集就可以知道位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dfs3(pacific,i, <span class="number">0</span>, heights);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    dfs3(pacific,<span class="number">0</span>, j, heights);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dfs3(atlantic,i, n - <span class="number">1</span>,heights );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    dfs3(atlantic,m - <span class="number">1</span>, j, heights);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs3</span><span class="params">(<span class="type">boolean</span> [][]ocean,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> [][]height)</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(ocean[i][j])<span class="keyword">return</span>;</span><br><span class="line">        ocean[i][j]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> newi=i+dir[<span class="number">0</span>],newj=j+dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newi&gt;=<span class="number">0</span> &amp;&amp; newi&lt;height.length &amp;&amp; newj&gt;=<span class="number">0</span> &amp;&amp; newj&lt;height[<span class="number">0</span>].length &amp;&amp; height[newi][newj]&gt;=height[i][j])</span><br><span class="line">                dfs3(ocean,newi,newj,height);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>此题同上一题类似寻找四周岛屿影响的内部岛屿</p>
<h3 id="778-水位上升的泳池中游泳-1631-最小体力消耗路径"><a href="#778-水位上升的泳池中游泳-1631-最小体力消耗路径" class="headerlink" title="778. 水位上升的泳池中游泳  1631. 最小体力消耗路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h3><p>此题融合了二分查找与dfs并存，使用二分查找来寻找到从左到右的最小路径。这是本问题具有的单调性。因此可以使用二分查找定位到最短等待时间。具体来说：在区间 [0, N * N - 1] 里猜一个整数，针对这个整数从起点（左上角）开始做一次深度优先遍历或者广度优先遍历。</p>
<p>当小于等于该数值时，如果存在一条从左上角到右下角的路径，说明答案可能是这个数值，也可能更小；<br>当小于等于该数值时，如果不存在一条从左上角到右下角的路径，说明答案一定比这个数值更大。<br>按照这种方式不断缩小搜索的区间，最终找到最少等待时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] DIRECTIONS = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">swimInWater</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.N=grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> N * N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">boolean</span> used [][]=<span class="keyword">new</span> <span class="title class_">boolean</span>[N][N];</span><br><span class="line">            <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]&lt;=mid&amp;&amp;dfs(grid,<span class="number">0</span>,<span class="number">0</span>,used,mid))&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">boolean</span>[][] used, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line">        used[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> dic[]:DIRECTIONS)&#123;</span><br><span class="line">            <span class="type">int</span> newx=x+dic[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> newy=y+dic[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(inArea(newx,newy)&amp;&amp;!used[newx][newy]&amp;&amp;grid[newx][newy]&lt;=mid)&#123;</span><br><span class="line">                <span class="keyword">if</span> (newx == N - <span class="number">1</span> &amp;&amp; newy == N - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dfs(grid, newx, newy, used, mid)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; N;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h3><p>按照树的遍历来计算所存在的边数方法一：Hierholzer 算法<br>思路及算法</p>
<p>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p>
<p>从起点出发，进行深度优先搜索。</p>
<p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p>
<p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p>
<p>当我们顺序地考虑该问题时，我们也许很难解决该问题，因为我们无法判断当前节点的哪一个分支是「死胡同」分支。</p>
<p>不妨倒过来思考。我们注意到只有那个入度与出度差为 111 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p>
<p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p>
<p>这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, PriorityQueue&lt;String&gt;&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; list:tickets)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span>list.get(<span class="number">0</span>);String des=list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(src))&#123;</span><br><span class="line">            map.put(src,<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(src).add(des);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="string">&quot;JHK&quot;</span>);</span><br><span class="line">    Collections.reverse(res); <span class="comment">// 反转链表，最先找到的是最深的不能再走的目的地，所以要反转过来</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String src)</span> &#123;</span><br><span class="line">    <span class="comment">// 当传入的参数是始发地而且还有边的时候，取边出队删除并且继续递归深搜这条边的点，一直到不能再走再返回</span></span><br><span class="line">    <span class="keyword">while</span> (map.containsKey(src) &amp;&amp; map.get(src).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dfs(map.get(src).poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有子递归可以调用时，递归函数开始返回，把搜过的点一次加到结果集的路线里</span></span><br><span class="line">    res.add(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2368-受限条件下可到达节点的数目"><a href="#2368-受限条件下可到达节点的数目" class="headerlink" title="2368. 受限条件下可到达节点的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/">2368. 受限条件下可到达节点的数目</a></h3><p><img src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" alt="img"></p>
<p>按照题目要求构建出树，然后dfs遍历遇到阻塞就跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reachableNodes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span>[] restricted)</span> &#123;</span><br><span class="line">        ArrayList &lt;Integer&gt;[]list=<span class="keyword">new</span> <span class="title class_">ArrayList</span> [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> []edge:edges)&#123;</span><br><span class="line">            list[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">            list[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r : restricted) vis[r] = <span class="literal">true</span>;</span><br><span class="line">        dfs(list,vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt;[] g, <span class="type">boolean</span>[] vis, <span class="type">int</span> fa)</span>&#123;</span><br><span class="line">        vis[fa]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> child:g[fa])&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[child])<span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            dfs(g,vis,child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><h4 id="834-树中距离之和-2581-统计可能的树根数目"><a href="#834-树中距离之和-2581-统计可能的树根数目" class="headerlink" title="834. 树中距离之和  2581. 统计可能的树根数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-distances-in-tree/">834. 树中距离之和</a>  <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/">2581. 统计可能的树根数目</a></h4><img src="https://pic.leetcode.cn/1689398667-omjvbD-lc834.png" alt="lc834.png" style="zoom:50%;">

<p>思路都为优先算出一次dfs从0开始的树初始情况，然后因为换节点只会影响该节点与其子节点关系所以使用dp公式保存遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2581. 统计可能的树根数目  https://leetcode.cn/problems/count-number-of-possible-root-nodes/description/?envType=daily-question&amp;envId=2024-02-29</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] times;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Long&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k, res, cnt0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rootCount</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span>[][] guesses, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.k = k;</span><br><span class="line">        times = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[edges.length + <span class="number">1</span>];</span><br><span class="line">            Arrays.setAll(times, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> e[<span class="number">1</span>];</span><br><span class="line">                times[x].add(y);</span><br><span class="line">                times[y].add(x); <span class="comment">// 建图</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] e : guesses) &#123; <span class="comment">// guesses 转成哈希表</span></span><br><span class="line">                s.add((<span class="type">long</span>) e[<span class="number">0</span>] &lt;&lt; <span class="number">32</span> | e[<span class="number">1</span>]); <span class="comment">// 两个 4 字节 int 压缩成一个 8 字节 long</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            reroot(<span class="number">0</span>, -<span class="number">1</span>, cnt0);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : times[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.contains((<span class="type">long</span>) x &lt;&lt; <span class="number">32</span> | y)) &#123; <span class="comment">// 以 0 为根时，猜对了</span></span><br><span class="line">                        cnt0++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dfs(y, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= k) &#123; <span class="comment">// 此时 cnt 就是以 x 为根时的猜对次数</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y : times[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y != fa) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> cnt;</span><br><span class="line">                    <span class="keyword">if</span> (s.contains((<span class="type">long</span>) x &lt;&lt; <span class="number">32</span> | y)) c--; <span class="comment">// 原来是对的，现在错了</span></span><br><span class="line">                    <span class="keyword">if</span> (s.contains((<span class="type">long</span>) y &lt;&lt; <span class="number">32</span> | x)) c++; <span class="comment">// 原来是错的，现在对了</span></span><br><span class="line">                    reroot(y, x, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//834. 树中距离之和  https://leetcode.cn/problems/sum-of-distances-in-tree/description/ </span></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] g;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] ans, size;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sumOfDistancesInTree(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    g = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n]; <span class="comment">// g[x] 表示 x 的所有邻居</span></span><br><span class="line">    Arrays.setAll(g, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> [] e : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e[<span class="number">0</span>], y = e[<span class="number">1</span>];</span><br><span class="line">        g[x].add(y);</span><br><span class="line">        g[y].add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dfs(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 0 没有父节点</span></span><br><span class="line">    reroot(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">// 0 没有父节点</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        ans[<span class="number">0</span>] += depth; <span class="comment">// depth 为 0 到 x 的距离</span></span><br><span class="line">        size[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123; <span class="comment">// 遍历 x 的邻居 y</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123; <span class="comment">// 避免访问父节点</span></span><br><span class="line">                dfs(y, x, depth + <span class="number">1</span>); <span class="comment">// x 是 y 的父节点</span></span><br><span class="line">                size[x] += size[y]; <span class="comment">// 累加 x 的儿子 y 的子树大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y : g[x]) &#123; <span class="comment">// 遍历 x 的邻居 y</span></span><br><span class="line">            <span class="keyword">if</span> (y != fa) &#123; <span class="comment">// 避免访问父节点</span></span><br><span class="line">                ans[y] = ans[x] + g.length - <span class="number">2</span> * size[y];</span><br><span class="line">                reroot(y, x); <span class="comment">// x 是 y 的父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h3><p>BFS 可以看成是层序遍历。从某个结点出发，BFS 首先遍历到距离为 1 的结点，然后是距离为 2、3、4…… 的结点。因此，BFS 可以用来求最短路径问题。BFS 先搜索到的结点，一定是距离最近的结点。</p>
<p>再看看这道题的题目要求：返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。翻译一下，实际上就是求腐烂橘子到所有新鲜橘子的最短路径。那么这道题使用 BFS，应该是毫无疑问的了。</p>
<p>如何写（最短路径的） BFS 代码<br>我们都知道 BFS 需要使用队列，代码框架是这样子的（伪代码）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> queue 非空:</span><br><span class="line">	node = queue.pop()</span><br><span class="line">    <span class="keyword">for</span> node 的所有相邻结点 m:</span><br><span class="line">        <span class="keyword">if</span> m 未访问过:</span><br><span class="line">            queue.push(m)</span><br></pre></td></tr></table></figure>

<p>但是用 BFS 来求最短路径的话，这个队列中第 1 层和第 2 层的结点会紧挨在一起，无法区分。因此，我们需要稍微修改一下代码，在每一层遍历开始前，记录队列中的结点数量 nnn ，然后一口气处理完这一层的 nnn 个结点。代码框架是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">depth = <span class="number">0</span> <span class="comment"># 记录遍历到第几层</span></span><br><span class="line"><span class="keyword">while</span> queue 非空:</span><br><span class="line">    depth++</span><br><span class="line">    n = queue 中的元素个数</span><br><span class="line">    循环 n 次:</span><br><span class="line">        node = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> node 的所有相邻结点 m:</span><br><span class="line">            <span class="keyword">if</span> m 未访问过:</span><br><span class="line">                queue.push(m)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=grid.length;</span><br><span class="line">    <span class="type">int</span> c=grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> []bad=queue.poll();</span><br><span class="line">            <span class="type">int</span> j=bad[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> k=bad[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[j-<span class="number">1</span>][k] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[j-<span class="number">1</span>][k]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j-<span class="number">1</span>,k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span> &lt;l &amp;&amp; grid[j+<span class="number">1</span>][k] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[j+<span class="number">1</span>][k]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j+<span class="number">1</span>,k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[j][k-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[j][k-<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j,k-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k+<span class="number">1</span> &lt;c &amp;&amp; grid[j][k+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[j][k+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j,k+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2684-矩阵中移动的最大次数"><a href="#2684-矩阵中移动的最大次数" class="headerlink" title="2684. 矩阵中移动的最大次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/">2684. 矩阵中移动的最大次数</a></h3><p>bfs 按照每一列满足条件的加入 遍历了无元素加入为止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxMoves</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Set&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            q.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            Set&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : q) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i - <span class="number">1</span>; i2 &lt;= i + <span class="number">1</span>; i2++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= i2 &amp;&amp; i2 &lt; m &amp;&amp; grid[i][j - <span class="number">1</span>] &lt; grid[i2][j]) &#123;</span><br><span class="line">                        q2.add(i2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q2;</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="拓扑结构（拓扑排序）"><a href="#拓扑结构（拓扑排序）" class="headerlink" title="拓扑结构（拓扑排序）"></a>拓扑结构（拓扑排序）</h2><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h3><p>这是一个包含 n个节点的有向图 G我们需要判断此有向图是否存在环路</p>
<p>我们将每一门课看成一个节点；</p>
<p>如果想要学习课程 A之前必须完成课程 B，那么我们从 B 到 A连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。</p>
<p>DFS思路</p>
<p>直接遍历，如果入度为0那么进行对其下一门课程遍历，如果一直到最后末尾都不会回到之前的课程那么则无环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">        edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS思路</p>
<p>我们先统计出入度为0 的项目的个数，遍历入度为0的节点，然后减少入度如果减少到也变成入度为0时加入，如果所有节点被加入那么就不存在环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">visited</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h3><p>BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">        edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">// 放入答案中</span></span><br><span class="line">        result[index++] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            --indeg[v];</span><br><span class="line">            <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">            <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="909-蛇梯棋"><a href="#909-蛇梯棋" class="headerlink" title="909. 蛇梯棋"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/snakes-and-ladders/">909. 蛇梯棋</a></h3><p>蛇形棋因为行列关系在奇偶数行时不同使用一个n*n的数组在不同奇偶数情况时去处理行列 之后遍历每次6个点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n * n + <span class="number">1</span>];</span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> p[]=queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> next=p[<span class="number">0</span>]+i;</span><br><span class="line">            <span class="keyword">if</span>(next&gt;n*n)<span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> []post=id2rc(next,n);</span><br><span class="line">            <span class="keyword">if</span>(board[post[<span class="number">0</span>]][post[<span class="number">1</span>]]&gt;<span class="number">0</span>)next=board[post[<span class="number">0</span>]][post[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">if</span>(next==n*n)<span class="keyword">return</span> p[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[next])&#123;</span><br><span class="line">                vis[next]=<span class="literal">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next,p[<span class="number">1</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] id2rc(<span class="type">int</span> id, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (id - <span class="number">1</span>) / n, c = (id - <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">if</span> (r % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        c = n - <span class="number">1</span> - c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span> - r, c&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h3><p>每层搜索将字母依次替换，然后用Hashmap记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">char</span>[] items = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String startGene, String endGene, String[] bank)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : bank) set.add(s);</span><br><span class="line">        Deque&lt;String&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        d.addLast(startGene);</span><br><span class="line">        map.put(startGene, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> size=d.size();</span><br><span class="line">            <span class="keyword">while</span> (size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                String s=d.pollFirst();</span><br><span class="line">                <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">                <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> map.get(s);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> c : items) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cs[i] == c) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">char</span>[] clone = cs.clone();</span><br><span class="line">                        clone[i] = c;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> String.valueOf(clone);</span><br><span class="line">                        <span class="keyword">if</span> (!set.contains(sub)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (map.containsKey(sub)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (sub.equals(endGene)) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        map.put(sub, step + <span class="number">1</span>);</span><br><span class="line">                        d.addLast(sub);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leecode/" rel="tag"># leecode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/09/cs-61B-note/" rel="prev" title="CS-61B">
      <i class="fa fa-chevron-left"></i> CS-61B
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/19/Spring%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">1、如何处理循环数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.</span> <span class="nav-text">2、二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I-%E8%80%83%E5%AF%9F%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">剑指 Offer 53 - I. 在排序数组中查找数字 I 考察二分法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-%E6%80%9D%E6%83%B3%E4%BE%9D%E7%84%B6%E6%98%AF%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">剑指 Offer 53 - II. 0～n-1中缺失的数字 思想依然是二分查找的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">287. 寻找重复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">4. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89"><span class="nav-number">1.2.0.7.</span> <span class="nav-text">378. 有序矩阵中第 K 小的元素 - 力扣（LeetCode）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.2.0.8.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E6%97%B6%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">3、删除数组时使用双指针法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">75. 颜色分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">581. 最短无序连续子数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">5、滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">424. 替换后的最长重复字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">567. 字符串的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">30. 串联所有单词的子串</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">1、基本排序介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-Bubble-Sort"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.冒泡排序(Bubble Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-Select-Sort"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.选择排序(Select Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-Insert-Sort"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.插入排序(Insert Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-Shell-Sort"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.希尔排序(Shell Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.快速排序(Quick Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-Merge-Sort"><span class="nav-number">2.1.6.</span> <span class="nav-text">6.归并排序(Merge Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort"><span class="nav-number">2.1.7.</span> <span class="nav-text">7.堆排序(Heap Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-Count-Sort"><span class="nav-number">2.1.8.</span> <span class="nav-text">8.计数排序 (Count Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%A1%B6%E6%8E%92%E5%BA%8F-Bucket-Sort"><span class="nav-number">2.1.9.</span> <span class="nav-text">9.桶排序(Bucket Sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-Raix-Sort"><span class="nav-number">2.1.10.</span> <span class="nav-text">10.基数排序(Raix Sort)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E5%92%8C"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">2386. 找出数组的第 K 大和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCR-170-%E4%BA%A4%E6%98%93%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0"><span class="nav-number">2.1.11.</span> <span class="nav-text">LCR 170. 交易逆序对的总数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.12.</span> <span class="nav-text">拓扑排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">1、206.反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">2、快慢指针法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%88%A4%E6%96%AD"><span class="nav-number">3.3.</span> <span class="nav-text">3、环形链表判断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E7%8E%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%AA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="nav-number">3.3.1.</span> <span class="nav-text">如果有环，如何找到这个环的入口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="nav-number">3.4.</span> <span class="nav-text">4、分割链表反转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%A4%B4%E8%8A%82%E7%82%B9pre%E6%9D%A5%E5%AE%8C%E6%88%90%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%96%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA-%E4%BE%8B%E5%A6%82%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%97%B6%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">使用虚拟构造一个头节点pre来完成对于一个新链表的创建  例如合并两个排序链表时就可以使用这个方法来创建一个新链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">147. 对链表进行插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text">148. 排序链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%90%88%E5%B9%B6k%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="nav-number">3.5.</span> <span class="nav-text">5、合并k个链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.5.1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%812-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">3.6.</span> <span class="nav-text">8、2. 两数相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%8125-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.7.</span> <span class="nav-text">7、25. K 个一组翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">3.7.1.</span> <span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">3.7.2.</span> <span class="nav-text">61. 旋转链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">4.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8Cmap%E9%81%8D%E5%8E%86"><span class="nav-number">4.1.</span> <span class="nav-text">哈希map遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#computeIfAbsent-%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">computeIfAbsent()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2808-%E4%BD%BF%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%92%E6%95%B0"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">2808. 使循环数组所有元素相等的最少秒数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="nav-number">4.2.</span> <span class="nav-text">1、基本哈希映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E6%AF%8D%E7%9B%B8%E5%90%8C%E5%93%88%E5%B8%8C%E6%80%9D%E8%B7%AF"><span class="nav-number">4.3.</span> <span class="nav-text">2、字母相同哈希思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%A4%9A%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">4.4.</span> <span class="nav-text">3、多数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81s%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E4%BB%A5%E4%B8%8A%E4%B8%8D%E9%80%82%E5%90%88%E7%94%A8%E5%93%88%E5%B8%8C-%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%AE%8C%E6%88%90"><span class="nav-number">4.5.</span> <span class="nav-text">4、s三数之和以上不适合用哈希 使用双指针法完成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81hashset%E5%8E%BB%E9%87%8D"><span class="nav-number">4.6.</span> <span class="nav-text">5、hashset去重</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#355-%E8%AE%BE%E8%AE%A1%E6%8E%A8%E7%89%B9"><span class="nav-number">4.6.1.</span> <span class="nav-text">355. 设计推特</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%95%B0%E5%BC%82%E6%88%96"><span class="nav-number">4.6.2.</span> <span class="nav-text">两数异或</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2935-%E6%89%BE%E5%87%BA%E5%BC%BA%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC-II"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">2935. 找出强数对的最大异或值 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="nav-number">4.6.3.</span> <span class="nav-text">828. 统计子串中的唯一字符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%951%EF%BC%9Achar-%E6%95%B0%E7%BB%84%E8%BD%AC%E6%88%90String%EF%BC%8C%E4%BD%BF%E7%94%A8-String-%E7%B1%BB%E7%9A%84-valueOf-%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">1.方法1：char[]数组转成String，使用 String 类的 valueOf() 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-valueOf-char-%E6%96%B9%E6%B3%95%E5%92%8C-Character-%E7%B1%BB%E7%9A%84-Character-toString-char-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">5.1.1.</span> <span class="nav-text">String.valueOf(char) 方法和 Character 类的 Character.toString(char)方法的区别：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-String-valueOf-char-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%B0%86char-%E5%92%8Cchar-%E5%8F%98%E9%87%8F%E5%90%8D%E8%BD%AC%E6%88%90String%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">1.String.valueOf(char) 方法可以将char[] 和char 变量名转成String类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Character-toString-char-%E6%96%B9%E6%B3%95%E5%8F%AA%E8%83%BD%E5%9C%A8char-%E5%8F%98%E9%87%8F%E5%90%8D%E8%BD%AC%E6%88%90String%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">2.Character.toString(char)方法只能在char 变量名转成String类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%AD%97%E7%AC%A6%E7%BF%BB%E8%BD%AC"><span class="nav-number">5.2.</span> <span class="nav-text">2、字符翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#796-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.2.1.</span> <span class="nav-text">796. 旋转字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81kmp%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">3、kmp算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89KMP%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%9D%E6%83%B3%E6%98%AF%E5%BD%93%E5%87%BA%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%E4%B8%80%E9%83%A8%E5%88%86%E4%B9%8B%E5%89%8D%E5%B7%B2%E7%BB%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E8%BF%99%E4%BA%9B%E4%BF%A1%E6%81%AF%E9%81%BF%E5%85%8D%E4%BB%8E%E5%A4%B4%E5%86%8D%E5%8E%BB%E5%81%9A%E5%8C%B9%E9%85%8D%E4%BA%86%E3%80%82"><span class="nav-number">5.3.1.</span> <span class="nav-text">（1）KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%89%80%E4%BB%A5%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E5%B7%B2%E7%BB%8F%E5%8C%B9%E9%85%8D%E7%9A%84%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%8C%E6%98%AFKMP%E7%9A%84%E9%87%8D%E7%82%B9%EF%BC%8C%E4%B9%9F%E6%98%AFnext%E6%95%B0%E7%BB%84%E8%82%A9%E8%B4%9F%E7%9A%84%E9%87%8D%E4%BB%BB%E3%80%82"><span class="nav-number">5.3.2.</span> <span class="nav-text">（2）所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%89%8D%E7%BC%80%E8%A1%A8"><span class="nav-number">5.3.3.</span> <span class="nav-text">（3）如何计算前缀表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2851-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.3.4.</span> <span class="nav-text">2851. 字符串转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Z-%E5%87%BD%E6%95%B0%EF%BC%88%E6%89%A9%E5%B1%95-KMP%EF%BC%89"><span class="nav-number">5.4.</span> <span class="nav-text">4.Z 函数（扩展 KMP）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">5.5.</span> <span class="nav-text">5、状态机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF"><span class="nav-number">5.6.</span> <span class="nav-text">318. 最大单词长度乘积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#670-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2"><span class="nav-number">5.7.</span> <span class="nav-text">670. 最大交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack"><span class="nav-number">6.1.</span> <span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue"><span class="nav-number">6.2.</span> <span class="nav-text">Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">6.3.</span> <span class="nav-text">PriorityQueue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LCP-30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F"><span class="nav-number">6.3.1.</span> <span class="nav-text">LCP 30. 魔塔游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#373-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E5%AF%B9%E6%95%B0%E5%AD%97"><span class="nav-number">6.3.2.</span> <span class="nav-text">373. 查找和最小的 K 对数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E6%A0%88%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">辅助栈法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">最小栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">字符串解码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">6.3.4.</span> <span class="nav-text">42. 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">6.3.5.</span> <span class="nav-text">621. 任务调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#502-IPO"><span class="nav-number">6.3.6.</span> <span class="nav-text">502. IPO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="nav-number">6.3.7.</span> <span class="nav-text">224. 基本计算器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">7.1.</span> <span class="nav-text">递归三要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">1、树的遍历方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.1.</span> <span class="nav-text">递归实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.2.2.</span> <span class="nav-text">迭代实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ps-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%98%E7%A7%8D"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">Ps:层序遍历变种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.2.3.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.2.3.1.</span> <span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.2.4.</span> <span class="nav-text">889. 根据前序和后序遍历构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2641-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9-II"><span class="nav-number">7.2.5.</span> <span class="nav-text">2641. 二叉树的堂兄弟节点 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">7.2.6.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.7.</span> <span class="nav-text">114. 二叉树展开为链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.3.</span> <span class="nav-text">2、特殊二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.3.1.</span> <span class="nav-text">完全二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2673-%E4%BD%BF%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7"><span class="nav-number">7.3.2.</span> <span class="nav-text">2673. 使二叉树所有路径值相等的最小代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.3.3.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">7.3.4.</span> <span class="nav-text">二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1"><span class="nav-number">7.3.5.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">7.3.5.1.</span> <span class="nav-text">数组构建二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">7.3.6.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2476-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.3.7.</span> <span class="nav-text">2476. 二叉搜索树最近节点查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="nav-number">7.3.8.</span> <span class="nav-text">117. 填充每个节点的下一个右侧节点指针 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">7.3.9.</span> <span class="nav-text">208. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-II"><span class="nav-number">7.3.10.</span> <span class="nav-text">212. 单词搜索 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.3.11.</span> <span class="nav-text">二叉树的垂序遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF"><span class="nav-number">8.</span> <span class="nav-text">回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="nav-number">8.1.</span> <span class="nav-text">回溯法模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">回溯法解决的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">8.2.1.</span> <span class="nav-text">剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">8.2.2.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#N%E7%9A%87%E5%90%8E"><span class="nav-number">8.2.3.</span> <span class="nav-text">N皇后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS%E4%B8%8EBFS"><span class="nav-number">8.3.</span> <span class="nav-text">DFS与BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF"><span class="nav-number">8.4.</span> <span class="nav-text">前缀和，递归，回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">8.4.1.</span> <span class="nav-text">437. 路径总和 III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">8.4.2.</span> <span class="nav-text">124. 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2602-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="nav-number">8.4.3.</span> <span class="nav-text">2602. 使数组元素全部相等的最少操作次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">8.4.4.</span> <span class="nav-text">22. 括号生成301. 删除无效的括号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">8.5.</span> <span class="nav-text">二维前缀和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="nav-number">8.5.1.</span> <span class="nav-text">304. 二维区域和检索 - 矩阵不可变</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">9.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-number">9.1.</span> <span class="nav-text">动态规划的解题步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9Adp%E6%95%B0%E7%BB%84%EF%BC%88dp-table%EF%BC%89%E4%BB%A5%E5%8F%8A%E4%B8%8B%E6%A0%87%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">9.1.1.</span> <span class="nav-text">确定dp数组（dp table）以及下标的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F"><span class="nav-number">9.1.2.</span> <span class="nav-text">确定递推公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dp%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">9.1.3.</span> <span class="nav-text">dp数组如何初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F"><span class="nav-number">9.1.4.</span> <span class="nav-text">确定遍历顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E6%8E%A8%E5%AF%BCdp%E6%95%B0%E7%BB%84"><span class="nav-number">9.1.5.</span> <span class="nav-text">举例推导dp数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">9.1.6.</span> <span class="nav-text">32. 最长有效括号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.1.6.1.</span> <span class="nav-text">300. 最长递增子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E7%A7%8D%E9%A2%981671-%E5%BE%97%E5%88%B0%E5%B1%B1%E5%BD%A2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0"><span class="nav-number">9.1.6.2.</span> <span class="nav-text">变种题1671. 得到山形数组的最少删除次数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">9.1.7.</span> <span class="nav-text">918. 环形子数组的最大和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1696-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-VI"><span class="nav-number">9.1.8.</span> <span class="nav-text">1696. 跳跃游戏 VI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">9.2.</span> <span class="nav-text">01背包理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">9.2.1.</span> <span class="nav-text">一维dp数组（滚动数组）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">9.3.</span> <span class="nav-text">完全背包理论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">9.4.</span> <span class="nav-text">多重背包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="nav-number">9.4.1.</span> <span class="nav-text">337. 打家劫舍 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">9.4.2.</span> <span class="nav-text">152. 乘积最大子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">9.4.3.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">9.4.4.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.4.5.</span> <span class="nav-text">1143. 最长公共子序列,718. 最长重复子数组 115. 不同的子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II%EF%BC%8C377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="nav-number">9.4.6.</span> <span class="nav-text">518. 零钱兑换 II，377. 组合总和 Ⅳ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE"><span class="nav-number">9.4.7.</span> <span class="nav-text">买卖股票类型题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III-%E6%A0%91%E5%BD%A2dp%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">9.4.7.1.</span> <span class="nav-text">337.打家劫舍 III 树形dp的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2008-%E5%87%BA%E7%A7%9F%E8%BD%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%88%E5%88%A9"><span class="nav-number">9.4.8.</span> <span class="nav-text">2008. 出租车的最大盈利</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1235-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C"><span class="nav-number">9.4.9.</span> <span class="nav-text">1235. 规划兼职工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2312-%E5%8D%96%E6%9C%A8%E5%A4%B4%E5%9D%97"><span class="nav-number">9.4.10.</span> <span class="nav-text">2312. 卖木头块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">9.4.11.</span> <span class="nav-text">221. 最大正方形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="nav-number">9.5.</span> <span class="nav-text">记忆化搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF"><span class="nav-number">9.5.0.1.</span> <span class="nav-text">514. 自由之路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1690-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-VII"><span class="nav-number">9.5.1.</span> <span class="nav-text">1690. 石子游戏 VII</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1312-%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0-516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.5.2.</span> <span class="nav-text">1312. 让字符串成为回文串的最少插入次数 516. 最长回文子序列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">10.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">10.0.1.</span> <span class="nav-text">402. 移掉 K 位数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="nav-number">10.0.2.</span> <span class="nav-text">316. 去除重复字母</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="nav-number">10.0.3.</span> <span class="nav-text">84. 柱状图中最大的矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="nav-number">10.0.4.</span> <span class="nav-text">85. 最大矩形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2454-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-IV"><span class="nav-number">10.0.5.</span> <span class="nav-text">2454. 下一个更大元素 IV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2866-%E7%BE%8E%E4%B8%BD%E5%A1%94-II"><span class="nav-number">10.0.6.</span> <span class="nav-text">2866. 美丽塔 II</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">11.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A6%96%E5%85%88%E8%A6%81%E7%9F%A5%E9%81%93%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">首先要知道并查集可以解决什么问题呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">11.1.1.</span> <span class="nav-text">存储数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6-1%EF%BC%9A%E5%B9%B3%E8%A1%A1%E6%80%A7%E4%BC%98%E5%8C%96"><span class="nav-number">11.1.2.</span> <span class="nav-text">优化角度 1：平衡性优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6-2%EF%BC%9A%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="nav-number">11.1.3.</span> <span class="nav-text">优化角度 2：路径压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E6%A8%A1%E7%89%88"><span class="nav-number">11.1.4.</span> <span class="nav-text">完整模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="nav-number">11.1.5.</span> <span class="nav-text">684. 冗余连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="nav-number">11.1.6.</span> <span class="nav-text">127. 单词接龙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7"><span class="nav-number">11.1.7.</span> <span class="nav-text">990. 等式方程的可满足性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="nav-number">11.1.8.</span> <span class="nav-text">399. 除法求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">12.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="nav-number">12.0.1.</span> <span class="nav-text">201. 数字范围按位与</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="nav-number">13.0.1.</span> <span class="nav-text">55. 跳跃游戏45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number">13.0.2.</span> <span class="nav-text">134. 加油站</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#846-%E4%B8%80%E6%89%8B%E9%A1%BA%E5%AD%90"><span class="nav-number">13.0.3.</span> <span class="nav-text">846. 一手顺子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1899-%E5%90%88%E5%B9%B6%E8%8B%A5%E5%B9%B2%E4%B8%89%E5%85%83%E7%BB%84%E4%BB%A5%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E4%B8%89%E5%85%83%E7%BB%84"><span class="nav-number">13.0.4.</span> <span class="nav-text">1899. 合并若干三元组以形成目标三元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">13.0.5.</span> <span class="nav-text">763. 划分字母区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2789-%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">13.0.6.</span> <span class="nav-text">2789. 合并后数组中的最大元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Intervals-%E6%8F%92%E7%A9%BA%E7%B1%BB%E9%A2%98%E7%9B%AE"><span class="nav-number">14.</span> <span class="nav-text">Intervals 插空类题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#678-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">14.0.1.</span> <span class="nav-text">678. 有效的括号字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">14.0.2.</span> <span class="nav-text">56. 合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">14.0.3.</span> <span class="nav-text">435. 无重叠区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1851-%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4"><span class="nav-number">14.0.4.</span> <span class="nav-text">1851. 包含每个查询的最小区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AE%AE%E5%AE%A4%E7%BB%8F%E5%85%B8%E9%A2%98"><span class="nav-number">14.0.5.</span> <span class="nav-text">会议室经典题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6"><span class="nav-number">15.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">15.1.</span> <span class="nav-text">快速幂</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">15.1.1.</span> <span class="nav-text">矩阵快速幂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1137-%E7%AC%AC-N-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">15.1.1.1.</span> <span class="nav-text">1137. 第 N 个泰波那契数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95%EF%BC%9A%E6%B1%82%E7%9A%84%E6%98%AF%E7%BB%9D%E5%AF%B9%E4%BC%97%E6%95%B0"><span class="nav-number">15.1.1.1.1.</span> <span class="nav-text">摩尔投票法：求的是绝对众数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">15.1.2.</span> <span class="nav-text">数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">15.1.3.</span> <span class="nav-text">13. 罗马数字转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98"><span class="nav-number">15.1.4.</span> <span class="nav-text">365. 水壶问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2575-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%AF%E6%95%B4%E9%99%A4%E6%95%B0%E7%BB%84"><span class="nav-number">15.1.5.</span> <span class="nav-text">2575. 找出字符串的可整除数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">15.1.6.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="nav-number">15.1.7.</span> <span class="nav-text">随机数生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">15.1.8.</span> <span class="nav-text">440. 字典序的第K小数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">15.1.9.</span> <span class="nav-text">8. 字符串转换整数 (atoi) 7. 整数反转</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">16.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">16.1.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="nav-number">16.1.1.</span> <span class="nav-text">417. 太平洋大西洋水流问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F"><span class="nav-number">16.1.2.</span> <span class="nav-text">130. 被围绕的区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3-1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84"><span class="nav-number">16.1.3.</span> <span class="nav-text">778. 水位上升的泳池中游泳  1631. 最小体力消耗路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="nav-number">16.1.4.</span> <span class="nav-text">332. 重新安排行程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2368-%E5%8F%97%E9%99%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-number">16.1.5.</span> <span class="nav-text">2368. 受限条件下可到达节点的数目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A2%E6%A0%B9dp"><span class="nav-number">16.1.6.</span> <span class="nav-text">换根dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#834-%E6%A0%91%E4%B8%AD%E8%B7%9D%E7%A6%BB%E4%B9%8B%E5%92%8C-2581-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%A0%91%E6%A0%B9%E6%95%B0%E7%9B%AE"><span class="nav-number">16.1.6.1.</span> <span class="nav-text">834. 树中距离之和  2581. 统计可能的树根数目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">16.2.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="nav-number">16.2.1.</span> <span class="nav-text">994. 腐烂的橘子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2684-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="nav-number">16.2.2.</span> <span class="nav-text">2684. 矩阵中移动的最大次数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">16.3.</span> <span class="nav-text">拓扑结构（拓扑排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="nav-number">16.3.1.</span> <span class="nav-text">207. 课程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II"><span class="nav-number">16.3.2.</span> <span class="nav-text">210. 课程表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#909-%E8%9B%87%E6%A2%AF%E6%A3%8B"><span class="nav-number">16.3.3.</span> <span class="nav-text">909. 蛇梯棋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#433-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96"><span class="nav-number">16.3.4.</span> <span class="nav-text">433. 最小基因变化</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stigwang</p>
  <div class="site-description" itemprop="description">show me the code！！！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stigwang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
